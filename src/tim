#!/usr/bin/env python
# coding: utf8
#
# Tim
# ===
# 
# project timer (GUI + cmdline)
# 
# You enter project names and start and stop them.
# Tim will keep track of how much you worked (and when) and how many of these
# worked hours you have already submitted to your money supplier.
# 
# (c) Copyright 2013 by Neels Janosch Hofmeyr <neels@hofmeyr.de> (GPLv3)
# 
# This file is part of Tim project timer.
# 
# Tim project timer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tim project timer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tim project timer.  If not, see <http://www.gnu.org/licenses/>.

r'''Tim project timer.

You enter names and start and stop them. Tim tracks how much you worked on
which (and when) and, if you like, how many of these worked hours you have
already submitted to your money supplier.

Make backups of your ~/.tim folder. It contains all of your time logs.

Launch a systray icon and GUI:
  tim systray

Command line usage:
  tim help [all|examples|<command-name>]
  tim [status]
  tim new <project-name>
  tim [start] <project-name> [-- <comment>]
  tim [adjust] [@<started-time>|+<duration>|-<duration>|=<duration>]
  tim stop [-- <comment>]
  tim stopped [-]<HH:MM> [-- <comment>]
  tim totals [round <duration>] [only <name>[.*][,...]] [-f] [-s]
  tim log [<nr>] [hours|days|weeks|months|years] \
          [from|until|before|after <date>] \
          [sum [<nr>] hours|days|weeks|months|years] \
          [round <duration>] [only <name>[.*][,...]] [-f]
  tim fix [<start-year>] [--clear] [--overlaps=shift|drop]
  tim tickoff <name> <hours> 
  tim tickoff <hours> <name> 
  tim tickoff --undo
  tim forge <start-date> <start-time> <name> <hours> [-- <comment>]
  tim rename <name> <new-name>
  tim forget <name>
  tim recall [<id>] [--as <name>] [--add-to <name>]

--- tim systray ---
Launch a systray icon. Tim should appear in your window manager's taskbar. Put
'tim systray' in your window manager's autostart. If you click the systray
icon, you can interact with Tim using your mouse ... if you're like that.

--- tim help ---
'tim help' without arguments shows a short usage of all commands.
For details on a command, type 'tim help <command-name>'.
For some examples, type 'tim help examples'.
For full help, type 'tim help all'.
  tim help new
  tim help start
  tim help help

--- tim status ---
Calling tim without arguments shows the current timer, if any is running. This
is the same as calling 'tim status'.

--- tim new ---
Announce a new project name. You can use dots '.' to create subgroups of
projects.
  tim new foo
  tim new yoyodyne.abc

--- tim start ---
When you start working on a given project, call 'tim start my_name'. The word
'start' can be omitted. Before you can start a name, you must tell Tim about
it with the 'tim new' command, just once for each name you want to use.

Project names can be grouped, simply by inserting dots in the name. Any number
of grouping levels is allowed. Any group name can still record timings, even
if it contains other names. Anything that makes sense to you... ;)

As soon as the project name is known with
  tim new my_group.my_name
you only need to type the part after the last dot, like
  tim my_name
Tim will find 'my_group.my_name' from that, as long as there is no other
'my_name' around in other groups.

You can supply a comment to go with the timing being started. If you do so,
just write the comment after the name to start. You may not omit the word
'start' when supplying a comment.
  tim start my_name My comment goes everywhere after the name.

The comment will be saved in the log, and it may be used to submit the timing
elsewhere. For example, the OpenGroupware export submits the comment to your
OpenGroupware server.

A running timer can be stopped with 'tim stop', 'tim stopped' or by starting a
different name. A running timer can also be adjusted, see 'tim help adjust'.
For starting in the past, see 'tim help started'.

--- tim started ---
Say, I have been working since 9 AM, but I forgot to start the timer then. No
timer has been running, but it should have. I can correct that by calling
  tim started my_name 9:00
This is a shortcut for 'tim start my_name' followed by 'tim adjust @9'.

If a timer is already running, use 'tim adjust' instead.
To create timings further in the past than a day ago, use 'tim forge'.

--- tim adjust ---
When a timer is currently running, adjust the recorded time. This always
shifts the started-time so that the desired duration results when counting up
to the current moment in time. The word 'adjust' may be omitted.

  @<started-time>
    I have actually started working on this project at <started-time>.
    Adjust the timing counter for the current project accordingly.
    <started-time> format is 'HH:MM', e.g. '14:59'. Wraps past midnight
    (yesterday's time is used when today's time would be in the future).
      tim @9      # make as if I called 'start' at 9 o'clock this morning
      tim @15:30  # "just joking, in fact I started at half past three."

  +<duration>
    Add <duration> to the currently running timer, make as if I started
    earlier.
    <duration>: [HH][:MM], for example:
      tim +1      # add one hour
      tim +1:30   # add one and a half hours
      tim +1.5    # add one and a half hours (decimal dot)
      tim +:30    # add thirty minutes

  -<duration>
    Subtract <duration>. '-10' is the same as '+-10'. Make as if I started
    later. This won't go below zero.

  =<duration>
    Set the current counter to exactly <duration> hours.
      tim =1      # make as if I called 'start' one hour ago

To adjust and stop at the same time, see 'tim help stopped'.

To change timings that have already stopped, you can edit the log file itself.
Log files are located in ~/.tim/timelog/ and named per year. The format is:
YYYY-MM-DD HH:MM my_name hh:mm # my comment
  meaning:
<start-datetime> <group> <hours> # <comment>
After you're done editing logs, be sure to call 'tim fix', see 'tim help fix'.

--- tim stop ---
Stop the currently running timer. Any arguments after the word 'stop' are
stored as a comment for the hours just worked.

When you stop a timer, it is recorded in the log and in the grand totals.
See 'tim help log' and 'tim help totals'.

To stop in the past, see 'tim help stopped'.

--- tim stopped ---
Say, I stopped working at half past three, but I forgot to stop the timer, and
it has been running in vain all afternoon. I can correct that by stopping the
timer with the 'stopped' command:
  tim stopped 15:30
This command goes back to half past three and stops the timer. The logs will
show that I stopped working at the time I really stopped working.

If you pass a negative time, 'stopped' subtracts hours from the current time.
If you forgot to stop the timer two and a quarter hours ago, simply call:
  tim stopped -2:15

Another way would be to subtract the surplus hours and stop then.
  tim adjust -2:15
  tim stop
This corrects the duration recorded in the logs, but it moves the starting
time forward by two hours fifteen minutes. If you want your logs to show
exactly at what times you started and stopped working, rather use the
'stopped' command, as it preserves the starting time and adjusts the stopping
time instead.

To change the starting time without stopping the timer, see 'tim help adjust'.

--- tim totals ---
Print the current timing totals. Shows hours spent, less hours ticked-off, on
a per-group and per-project basis.

This adds timings of all names in a group up to the group's own total. So if
you have employer 'yoyo' and projects 'foo' and 'bar', you will start and stop
timings on 'yoyo.foo' and 'yoyo.bar'. They get positive totals. When you
submit worked hours to Yoyo, you can tick off on 'yoyo' instead of the
specific projects. The timings for 'yoyo' become negative. But in the totals,
'foo' and 'bar' are added to its parent 'yoyo', so that 'yoyo' reaches zero
when all worked hours have been ticked off.

Options:

  only <name>[,<name>[,...]]
    Limit the listing to the given names.

  round <duration>
    Show timings rounded to <duration>. For example, 'round 0:15' rounds
    timings to the closest quarter-of-an-hour (1:07 becomes 1, 1:08 becomes
    1:15). While rounding, a surplus sum is made per name, which will
    influence subsequent roundings. This makes sure that the sum of minutes
    gained or lost by rounding stays within reasonable bounds. So, any minutes
    lost because of rounding will be remembered and given back to you at the
    next upcoming rounding (and vice versa, of course).
    For example, when rounding the following timings to a full hour:
      1:10; 1:10; 1:10; 1:50; 1:50
    with 'round 1' (or 'round 1:00'), these become:
      1:00; 1:00; 2:00; 1:00; 2:00
    This makes sense when you look at the surplus added up in the background:
      1:10  round down to 1:00, keep +0:10 surplus.
      1:10  add surplus = 1:20. Round down to 1:00, now + 0:20 surplus.
      1:10  + 0:20 = 1:30. Round *up* to 2:00, keep - 0:30 surplus.
      1:50  - 0:30 is 1:20. Round down to 1:00, keep + 0:20 surplus.
      1:50  + 0:20 is 2:10. Round down to 2:00, keep + 0:10 surplus.
    Show final surplus with the -s option.

  -f
    Flat. Show timings separately for each group, do not add them up to the
    parent groups. This might help to examine ticked off hours.

  -s
    Show surplus. If you passed a rounding argument, the rounding will
    probably have a bit too many or too few minutes after all timings have
    been rounded. This option shows these final surplus minutes.

To show how the totals came about, see 'tim help log'. To fix the totals if
they got out of sync (because you edited the timelogs?), see 'tim help fix'.

--- tim log ---
Show the timings for this week ('1 week' is the default).

This also shows a sum of the timings that are selected.

Selecting a time period is done in rough english. Examples:
  tim log 2 weeks
  tim log 1 month                  # starts at the beginning of this month
  tim log 1 month before now       # starts ~30 days ago
  tim log 1 week after 2012-08-31
  tim log 3 months before 2013-01
The words can be abbreviated down to their starting letters, and the default
amount is 1. These commands are equivalent to those above:
  tim log 2 w
  tim log mon
  tim log m b n
  tim log w a 2012-08-31
  tim log 3 m b 2013
Available tokens:
  days weeks months years -- a time unit.
  from <date>   -- take the given date as starting point, including <date>.
  until <date>  -- take the given date as end point, including <date>.
  after <date>  -- like 'from', but EXCLUDING <date>.
  before <date> -- like 'until', but EXCLUDING <date>.
  exactly       -- do not snap to day/week/month start.
  only <names>  -- show logs for only the given names.
  sum <unit>

A <date> is of the format 'YYYY-MM-DD_hh:mm', where parts of it may be
omitted. If <date> starts with a dash, the current year is inserted:
  YYYY-MM-DD_hh:mm
  YYYY-MM-DD
  YYYY-MM
  YYYY
  -MM
  -MM-DD
Start with a literal, capital 'W' to issue a week number, with formats:
  'W'WW
  YYYY-'W'WW
Examples:
 tim log after 2013-01-11 = after 00:00 on 11th of January, 2013.
 '2013-01-11_23:45' = 23:45 on 11th of January, 2013.
 '-10' = 10th of this month, 0:00 AM.
 '-1-1' = first of January, this year.
 '2013' = new year's 2013, 0:00 AM.
 '2012-W20' = twentieth week in 2013
 'W1' = first week this year

<names> is a list of comma-separated timing names, without spaces. Append '.*'
to a name to include all its subgroups.
  tim log only yoyodyne.abc.*,foo

By default, log shows every single timing. You can add up timings within a
given time period with a 'sum' argument:
  tim log sum days
This shows the log for this week, but only each day's total, with a list of
names involved on that day. 'sum' can also be abbreviated down to 's'.
'sum' also takes numbers and the 'full' argument:
  tim log 1 year sum 3 months
adds up each quartal of the year.
  tim log sum full days
shows this week's timings starting on monday, and takes the current time as
the end-of-a-day boundary (may be useful if you work around midnight and don't
want those timings to be divided between two calendar days).
  
Options:
  -l <name>
    Limit the listing to this project (or group).

  -f
    Flat. Show timings separately for each group, do not add them up to the
    parent groups. This might help to examine ticked off hours.

To fix any errors in the logs (because you edited them?), see 'tim help fix'.

--- tim fix ---
'tim fix' is always a good idea, particularly after you have forged timings,
edited the logs manually or recently recovered from catastrophic hardware
failure.

This runs through the logs and fixes by
- putting timings in their correct year logs,
- sorting timing logs,
- verify and correct the grand total shown by 'tim totals',
- verify and correct the initial totals at the beginning of each log file;

This is particularly useful for editing the recorded timings: simply edit the
log files in ~/.tim/timelog/, then call 'tim fix' to carry the edits through
to the proper log files and the current grand total.

Without arguments, all available years are checked and corrected. Each year's
final totals are carried over to the next year's initial totals. You can ask
tim to start at a given year if you don't want to run through all of them.
This will *always* run all the way to the present, and will finally adjust the
current grand totals on record if necessary (those shown by 'tim totals').

You can provide the option '--clear' to erase the initial totals of the
starting year. When calling 'tim fix --clear', the first log handled will
have its initial totals reset to zero.

If any overlapping timings are found, --overlaps selects the way to fix:
  --overlaps=shift  -- push later timings towards the future (chain reaction!)
  --overlaps=drop   -- drop all those hours counted twice (lossy!)
  --overlaps=ignore -- don't show any overlap warnings
The default is to leave overlaps as they are, while warning about their
existence.

Examples:
  tim fix
  tim fix --overlaps=shift
  tim fix 2012      # starts with 2012 and ends with the latest log on record

--- tim tickoff ---
Record hours that you have already billed your money supplier for. If you are
timing private / hobby projects, your total hours will simply grow. But if you
have an employer, ticking off is useful to keep track of how many hours you
have actually passed on to your employer's accounting.

When using 'tickoff' for any given project, you probably want to reach a total
of zero for that project at regular intervals. If you've worked less than you
billed, your total hours become negative.

You can tickoff on any name, on any grouping levels you choose. Ticking off a
parent group is useful when no precise per-project tickoffs are needed. When
you run 'tim totals', your parent group's tickoffs neutralize the hours added
up from the subprojects, so by ticking off you ideally reach zero on the
parent group.
  tim tickoff 6 yoyodyne
  tim tickoff 30:30 upperstarter.foo
  tim tickoff 1:30 upperstarter.bar

If a group's total is negative, you've already ticked off more hours than you
have recorded; in other words, you've billed hours in advance. Over time, as
you record more timings, the negative value will approach positive numbers.

You can undo the latest tickoffs one by one with:
  tim tickoff --undo

--- tim forge ---
Create a timing some time in the past. This is the same as editing the logs in
~/.tim/timelogs. You should call 'tim fix' after you're done forging timings.

Arguments:
- a name,
- a start date with time-of-day,
- and a duration.

For example, to create a timing from noon on 28th of January 2013 until four
thirty (four and a half hours later):

  tim forge 2013-01-28 12:00 foo 4:30

If a negative amount of hours is supplied, the timing will end with the given
time-of-day.

--- tim rename ---
Rename a project while keeping its hours and logs. This may also move projects
around between groups.
Note that this changes the name in all logs back to the start of time, so the
'tim log' command will not look the same as before.

--- tim forget ---
Remove a given project from accounting. The data will still be sitting in the
database, but it will appear to be completely removed with all its history
when interacting with tim.

--- tim remember ---
Recover a project previously forgotten with 'tim forget'. Run without
arguments to get a listing of IDs for forgotten projects or groups.

--- EXAMPLE ---
This example shows a sequence of tim commands. Imagine that time passes
between each pair of start ... stop commands.
  
  tim new foo
  tim foo
  tim stop
  tim foo
  tim stop

  tim new yoyodyne.abc     # announce project abc in group yoyodyne
  tim yoyodyne.abc         # start timing for project abc in the group yoyodyne
  tim +1                   # fake starting-time so that I've worked 1 hour now
  tim stop "fix a bug"     # stop timing, record in the log with a message
  tim abc                  # start yoyodyne.abc; tim finds 'abc' in 'yoyodyne'.
  tim stop
  tim new yoyodyne.xyz.bar # announce project bar in new group yoyodyne.xyz
  tim xyz                  # start yoyodyne.xyz (yes, "groups" can also start)
  tim abc                  # stop yoyodyne.xyz, start yoyodyne.abc, in one go
  tim stop

  tim log                  # show the log of this week (starting monday)
  tim log 5 weeks exactly  # show last five weeks (five times seven days)
  tim log only yoyodyne.*  # show log for yoyodyne.* projects only
  tim log 5 w e            # same as '5 weeks exactly'
  tim log o yoyodyne.*     # same as 'only yoyodyne.*'

  tim totals               # show the sum of all hours for all projects
  tim tickoff 32 yoyodyne  # I have billed yoyodyne for 32 hours.
  tim totals               # Above 32 hours are now subtracted from the totals.
'''

import re, os, errno, time, shutil, sys, signal, math, traceback
import daemon
from os.path import join as j

global_timewarp = 0
def now():
  global global_timewarp
  return time.time() + global_timewarp


# messaging and error handling ###############################################

def msgs2str(*msgs):
  return ''.join([str(m) for m in msgs])

class Error(Exception):
  def __init__(self, *msgs):
    self.msg = msgs2str(*msgs)
  def __str__(self):
    return str(self.msg)

def _raise(*msgs):
  raise Error(*msgs)

def _warn(*msgs):
  print '***', msgs2str(*msgs)

def _msg(*msgs):
  print msgs2str(*msgs)

def _errmsg(*msgs):
  sys.stderr.write('*** ')
  for msg in msgs:
    sys.stderr.write(msg)
  sys.stderr.write('\n')
  sys.stderr.flush()
  
def _debug(*msgs):
  lines = [('####### ' + line) for line in msgs2str(*msgs).split('\n')]
  print '\n'.join(lines)
  sys.stdout.flush()

def handle_error(e):
  _errmsg(str(e))
  ### debug output:
  sys.stderr.write('----- stacktrace -----\n')
  sys.stderr.write(traceback.format_exc())

# generic conversion functions ###############################################

def mins2str(float_mins, always_show_sign=False):
  sign = 1
  frac = 59.0
  if float_mins < 0:
    float_mins = -float_mins
    sign = -1
    frac = 1.0
  
  minutes = int(float_mins)
  if float_mins - float(minutes) > (frac/60):
    minutes += 1

  h, m = divmod(minutes, 60)

  if m == 0:
    rstr = str(sign * h)
  else:
    rstr = '%d:%02d' % (h,m)
    if sign < 0:
      # just 'h *= sign' won't work if h == 0.
      rstr = '-%s' % rstr

  if always_show_sign and rstr[0] != '-':
    return '+%s' % rstr
  return rstr

class FormatError(Error):
  pass

def str2mins(str_hours, raise_on_err=True):
  try: 
    if str_hours.find(':') < 0:
      return int(round(float(str_hours) * 60.0))

    h, m = str_hours.split(':')
    sign = 1
    if h.startswith('+'):
      h = h[1:]
    if h.startswith('-'):
      h = h[1:]
      sign = -1

    if not h or len(h) < 1:
      fh = 0
    else:
      fh = float(h)

    if not m or len(m) < 1:
      fm = 0
    else:
      fm = float(m)

    return int(sign * round(fh * 60.0 + fm))
  except ValueError, e:
    if raise_on_err:
      raise FormatError("Not a time string: '", str_hours, "'")
    return None

TIMESTR_FORMAT = "%Y-%m-%d %H:%M"
FILENAME_TIMESTAMP_FORMAT = "%Y_%m_%d_%H_%M_%S"

def time2str(float_time, fmt=TIMESTR_FORMAT):
  if not float_time:
    return None
  return time.strftime(fmt, time.localtime(float(float_time)))

def str2time(string, fmt=TIMESTR_FORMAT):
  if not string or len(string) < 1:
    return None
  return time.mktime( time.strptime(string, fmt) )

def time2year(float_time):
  return int(time.localtime(float_time).tm_year)

def time2weekday(float_time):
  # time_struct has monday == 0, while strptime() has sunday == 0.
  # convert to sunday == 0.
  return (int(time.localtime(float_time).tm_wday) + 1) % 7

def time2weekdaystr(float_time, weekday_strings={
    0:'Sunday', 1:'Monday', 2:'Tuesday', 3:'Wednesday', 4:'Thursday',
    5:'Friday', 6:'Saturday'}):
  return weekday_strings[time2weekday(float_time)]

def filename_timestamp(float_time=None):
  if float_time is None:
    float_time = float(now())
  return time.strftime(FILENAME_TIMESTAMP_FORMAT,
                       time.localtime(float(float_time)))

UNIT_HOUR = 0
UNIT_DAY = 1
UNIT_WEEK = 2
UNIT_MONTH = 3
UNIT_YEAR = 4

def date_beginning_of(unit, date):
  if UNIT_HOUR == unit:
    round_fmt = '%Y %j %H'
  elif UNIT_DAY == unit:
    round_fmt = '%Y %j'
  elif UNIT_WEEK == unit:
    round_fmt = '%Y %W'
  elif UNIT_MONTH == unit:
    round_fmt = '%Y %m'
  elif UNIT_YEAR == unit:
    round_fmt = '%Y'

  rounded_str = time2str(date, fmt=round_fmt)
  
  if UNIT_WEEK == unit:
    # strptime with %W (week of year) only works with %w (day of week).
    # So add 'Monday'.
    round_fmt += ' %w'
    rounded_str += ' 1'

  res = str2time( rounded_str, fmt=round_fmt)
  return res
  
def date_end_of(unit, date):
  res =  date_beginning_of(unit,
                           date_beginning_of(unit, date)
                             + 1.5 * date_seconds_per(unit))
  return res
  
def date_add(amount, unit, date):
  amount_frac, amount_int = math.modf(amount)
  amount_int = int(amount_int)
  seconds_per_unit = date_seconds_per(unit)
  # integer part
  if amount_int:
    beginning = date_beginning_of(unit, date)
    surplus = date - beginning
    mid = beginning + seconds_per_unit/2
    mid += seconds_per_unit * amount_int
    result = date_beginning_of(unit, mid) + surplus
  else:
    result = date
  # fractional part
  result += amount_frac * seconds_per_unit
  return result

def date_subtract(amount, unit, date):
  return date_add(-amount, unit, date)

def date_seconds_per(unit):
  if UNIT_HOUR == unit:
    return 60.*60
  elif UNIT_DAY == unit:
    return 60.*60*24
  elif UNIT_WEEK == unit:
    return 60.*60*24*7
  elif UNIT_MONTH == unit:
    return 60.*60*24*(365.25/12)
  elif UNIT_YEAR == unit:
    return 60.*60*24*365.25

# os file & process functions ################################################

def write_file(path, contents, mkdirs=True):
  if mkdirs:
    dirname = os.path.dirname(path)
    if not os.path.exists(dirname):
      os.makedirs(dirname)
  f = open(path, "w")
  f.write(contents)
  f.flush()
  os.fsync(f.fileno())
  f.close()

def append_to_file(path, contents, makedirs=True):
  if makedirs:
    parent_dir = os.path.dirname(path)
    if not os.path.isdir(parent_dir):
      os.makedirs(parent_dir)
  f = open(path, "a")
  f.write(contents)
  f.close()

def read_file(path):
  try:
    f = open(path, "r")
    contents = f.read()
    f.close()
    return contents
  except IOError:
    return None

def read_file_lines(path):
  try:
    f = open(path, "r")
    contents = f.readlines()
    f.close()
    return contents
  except IOError:
    return None

def process_is_running(pid):
  try:
    os.kill(int(pid), 0)
    return True
  except OSError as e:
    if e.errno == errno.ESRCH: # no such process
      return False
    raise

def gently_kill_process(pid):
  if not (pid and process_is_running(pid)):
    return True
  _msg('kill -SIGINT ', pid)
  os.kill(pid, signal.SIGINT)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  _msg('kill -SIGTERM ', pid)
  os.kill(pid, signal.SIGTERM)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  _msg('kill -SIGKILL ', pid)
  os.kill(pid, signal.SIGKILL)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  return False
 

# strings and regexes ########################################################

INITIAL_TOTAL_KEYWORD = 'init:'
NAME_RE = '([a-zA-Z_][a-zA-Z0-9_]*\.)*[a-zA-Z_][a-zA-Z0-9_]*'
NAMES_RE = '(' + NAME_RE + ')(,' + NAME_RE + ')*'
NAME_STR_RE = '\A' + NAME_RE + '\Z'
NAMES_STR_RE = '\A' + NAMES_RE + '\Z'
TIME_RE = '[+-]{0,1}[0-9:]+'
DATE_RE = r'(\d{1,4})-(\d{1,2})-(\d{1,2})[_ ](\d{1,2})[-:](\d{1,2})'
TOTAL_RE = '(' + NAME_RE + ')=(' + TIME_RE + ')'
TOTALS_LINE_RE = '^' + TOTAL_RE + '$'
LOG_INITIAL_TOTAL_RE = '^' + INITIAL_TOTAL_KEYWORD + ' *(.*) *$'
TIMING_RE = '^' + DATE_RE + '[: ]+([^ ]+) (' + TIME_RE + ')($| *# {0,1}(.*)$)'
STATE_RE = '^([0-9]+) (.*)$' # a PID, and a log entry (parsed in second step)

name_syntax_docstr = (
'''A name may contain letters a-z, A-Z, decimal numbers and the underscore _;
A name may not start with a number. Names can be arranged in groups by using
a dot to separate group levels: 'tim new my_group.my_inner_group.my_name'.''')

class Regex:
  '''Caches compiled regular expressions. A call to
  Regex.match('([a-z]*) ([0-9]*)', 'foo 123') returns a re.match object and
  compiles that regex only once, no matter how often match() is called.'''
  cache = {}
  @staticmethod
  def compiled(regex):
    compiled = Regex.cache.get(regex)
    if not compiled:
      compiled = re.compile(regex)
      Regex.cache[regex] = compiled
    return compiled
  @staticmethod
  def match(regex, string):
    return Regex.compiled(regex).match(string)
    

# classes implementing Tim ###################################################

class Notify(object):
  ALREADY_RUNNING = 0
  STARTED = 1
  STOPPED = 2
  STALE = 3
  MSG = 4
  WARN = 5
  ERROR = 6
  FIX_NEEDED = 7

  def __init__(self, notify_func):
    ''' notify_func(key, arg): function that notifies the user; the
    calling code can/should show these messages to the user in some way.

    key: One of the Notify.CONSTANTs
    
    arg: depends on the key...

      Notify.STARTED,
      Notify.ALREADY_RUNNING:
        arg: the name of the project that was successfully started / stopped
              / was not started since the same name is already running.

      Notify.STOPPED,
        arg: a State instance reflecting the state that has just been stopped
             and recorded in the time log.

      Notify.STALE:
        arg: (state, reason)
             state: a State instance like with Notify.STOPPED.
             reason: a short string meaning
               reason == State.REASON_STALE:
                 The state was last updated too long ago, i.e.  state.started
                 and state.minutes don't add up to the current time.
               reason == State.REASON_DAEMON_EXITED:
                 There is no process with PID == state.pid, so the daemon
                 updating the state has exited.
             A stale state is a running state that has not been updated for a
             long time, maybe because the machine was suspended or crashed.
             The timing was saved to the time log, only counting the time that
             the state was being updated (state.timing.minutes).

      Notify.MSG,
      Notify.WARN,
      Notify.ERROR:
        arg: a message to display.
    '''
    self.notify_func = notify_func

  def msg(self, *msgs):
    if self.notify_func:
      self.notify_func(Notify.MSG, msgs2str(*msgs))

  def warn(self, *msgs):
    if self.notify_func:
      self.notify_func(Notify.WARN, msgs2str(*msgs))

  def err(self, *msgs):
    if self.notify_func:
      self.notify_func(Notify.ERROR, msgs2str(*msgs))

  def notify(self, notify_id, arg):
    if self.notify_func:
      self.notify_func(notify_id, arg)


class Timing:
  def __init__(self, **kwargs):
    self.set_values(**kwargs)
  
  def set_values(self, started=None, name=None, minutes=None, comment=None):
    if name:
      Timelog.validate_name(name)
    self.started = started
    self.name = name
    self.minutes = minutes
    self.comment = comment
    if not self.comment:
      self.comment = None
    return self

  def matches(self, other):
    return (
      (other.started is None or self.started == other.started)
      and (other.name is None or self.name == other.name)
      and (other.minutes is None or self.minutes == other.minutes)
      and (other.comment is None or self.comment == other.comment))

  def __cmp__(self, other):
    c = cmp(self.started, other.started)
    if c: return c
    c = cmp(self.name, other.name)
    if c: return c
    c = cmp(self.minutes, other.minutes)
    if c: return c
    c = cmp(self.comment, other.comment)
    return c

  def clear(self):
    self.set_values()

  def started_str(self):
    return time2str(self.started)

  def serialize(self):
    return repr(self) + '\n'

  def to_string(self, rounder=None):
    if self.started:
      started_str = self.started_str()
    else:
      started_str = 'not_started'
    minutes = self.minutes
    if rounder:
      minutes = rounder.round(self.name, minutes)
    elts = [started_str,
            self.name or 'unnamed',
            mins2str(minutes or 0)]
    if self.comment:
      elts.append('#')
      elts.append(self.comment)
    return ' '.join(elts)

  def __str__(self):
    return repr(self)

  def __repr__(self):
    return self.to_string()

  def deserialize(self, line):
    match = Regex.match(TIMING_RE, line)
    if not match:
      return None
    else:
      self.set_values(
                    started=str2time('%s-%s-%s %s:%s' % match.groups()[0:5]),
                    name=match.group(6),
                    minutes=str2mins(match.group(7)),
                    comment=match.group(9),
                   )
      return self

  def add_comment(self, comment):
    'Append to current comment. Return True iff self.comment changed.'
    if comment:
      was = self.comment
      self.comment = (self.comment or '') + comment
      if was != self.comment:
        return True
    return False

  def started_year(self):
    return time2year(self.started)

  @staticmethod
  def _rename_str(name, from_name, to_name):
    new_name = None
    if from_name == name:
      new_name = to_name
    else:
      l = len(from_name)
      if name.startswith(from_name) and (len(name) > l) and name[l] == '.':
        new_name = to_name + name[l:]
    if new_name is not None:
      Timelog.validate_name(new_name)
    return new_name

  def rename(self, from_name, to_name):
    new_name = Timing._rename_str(self.name, from_name, to_name)
    if new_name is not None:
      self.name = new_name
      return True
    return False


      
class State:
  STOPPED = 'stopped'
  STARTING = 'starting'

  def __init__(self, state_file_path, read=True):
    self.timing = Timing()
    self.pid = None
    self.state_file_path = state_file_path
    if self.state_file_path and read:
      self.read()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    if self.timing.started:
      return str(self.pid) + ' ' + self.timing.serialize()
    else:
      return State.STOPPED

  def set_values(self, pid=None, **kwargs):
    self.pid = pid
    return self.timing.set_values(**kwargs)

  def serialize(self):
    return repr(self) + '\n'

  def deserialize(self, string):
    match = Regex.match(STATE_RE, string)
    if not match:
      return False
    # State only adds the pid field to Timing, so
    # STATE_RE only adds a pid nr to TIMING_RE
    self.pid = int(match.group(1))
    self.timing.deserialize(match.group(2))
    return True

  def save(self):
    "write this state to file"
    write_file(self.state_file_path, self.serialize())
    return self

  def write_starting(self):
    write_file(self.state_file_path, State.STARTING)

  def clear(self):
    self.pid = None
    self.timing.clear()

  def read(self):
    self.clear()

    if not os.path.isfile(self.state_file_path):
      return False

    statestr = read_file(self.state_file_path)
    if statestr is None:
      return True # stopped. no data.
    statestr = statestr.strip()
    if statestr == State.STOPPED:
      return True # stopped. no data.
    if statestr == State.STARTING:
      _debug('waiting...')
      for n in range(50):
        time.sleep(0.2)
        statestr = read_file(self.state_file_path)
        if State.STARTING != statestr:
          _debug('...success!')
          return self.read()
      _debug('...failure.')
      # The daemon had enough time to start. Something is wrong. Clear.
      self.clear()
      self.save()
      return True

    return self.deserialize(statestr)

  REASON_STALE = 'stale'
  REASON_DAEMON_EXITED = 'daemon exited'

  def is_stale(self):
    assert(self.timing.started)
    expected_now = (self.timing.started 
                    + (self.timing.minutes * Tim.seconds_per_minute))
    timestep = now() - expected_now
    if timestep > Tim.stale_threshold:
      return State.REASON_STALE
    if not process_is_running(self.pid):
      return State.REASON_DAEMON_EXITED
    return None


class MinutesRounder:
  def __init__(self, round_to_minutes):
    if (not round_to_minutes) or (round_to_minutes == 1):
      self.enabled = False
      return
    self.round_to_minutes = round_to_minutes
    self.enabled = True
    self.clear_surplus()

  def clear_surplus(self):
    self.surplus = {}

  def round(self, name, minutes):
    if not self.enabled:
      return minutes
    minutes = int(minutes)
    # first add previous surplus, if any. Then do the rounding, and
    # then remember the new surplus for this name.
    minutes = float(minutes) + (self.surplus.get(name) or 0)
    amount = minutes / self.round_to_minutes
    amount_frac, amount_int = math.modf(amount)
    if amount_frac >= 0.5:
      amount_int += 1
    elif amount_frac <= -0.5:
      amount_int -= 1

    rounded_minutes = int(amount_int * self.round_to_minutes)

    surplus = minutes - rounded_minutes
    if surplus != 0:
      self.surplus[name] = surplus
    return rounded_minutes


class Totals:
  def __init__(self, totals_path=None, read=True):
    self.entries = {}
    self.totals_path = totals_path
    self.modified = False
    if totals_path and read:
      self.read()

  def set_to(self, other_totals_instance):
    self.entries = other_totals_instance.entries.copy()
    self.modified = True
    return self

  def copy(self):
    return Totals().set_to(self)


#  def add_all(self, other_totals_instance):
#    for name, minutes in other_totals_instance.iteritems():
#      self.add_time(name, minutes)

  class TotalsErr(Error):
    pass

  def add_name(self, name):
    if name in self.entries:
      raise Totals.TotalsErr('Already exists: ', name)
    self.entries[name] = 0
    self.modified = True

  def add_time(self, name, minutes):
    self.entries[name] = (self.get(name) or 0) + minutes
    self.modified = True

  def add_timing(self, timing):
    self.add_time(timing.name, timing.minutes)

  def remove_timing(self, timing):
    self.add_time(timing.name, -timing.minutes)

  def get(self, *args):
    return self.entries.get(*args)

  def iteritems(self):
    return self.entries.iteritems()

  def __iter__(self, *args):
    return self.entries.__iter__(*args)

  def __eq__(self, other):
    return self.entries.__eq__(other.entries)
  def __ne__(self, other):
    return self.entries.__ne__(other.entries)

  def is_empty(self, only=None):
    if not only:
      return not self.entries
    return not [item for item in self.entries if item in only]

  def deserialize(self, line):
    match = Regex.match(TOTALS_LINE_RE, line)
    if not match:
      raise Totals.TotalsErr('Line does not match "' + TOTALS_LINE_RE + '"')
    name = match.group(1)
    Timelog.validate_name(name)
    minutes = str2mins(match.group(3))
    if name in self.entries:
      raise Totals.TotalsErr('Duplicate name: ' + name)
    self.entries[name] = minutes

  def read(self):
    lines = read_file_lines(self.totals_path)
    self.entries = {}
    if lines:
      line_nr = 0
      for line in lines:
        line_nr += 1
        if not line.strip():
          continue
        self.deserialize(line)
    self.modified = False

  def get_serialized_items(self):
    return [ ( '%s=%s\n' % (name, mins2str(minutes)) )
            for name, minutes in sorted(self.iteritems())]

  def __repr__(self):
    return ''.join(self.get_serialized_items())

  def save(self):
    assert(self.totals_path)
    write_file(self.totals_path, repr(self))
    self.modified = False

  def clear(self):
    self.entries = {}
    self.modified = True

  def to_string(self, flat=False, only=None, omit_zero=False, rounder=None,
                clear_rounder=True):
    '''flat: if True, each line shows a full name, all in one column.
             If False, indents subgroups.
       only: A list of project names (str). If None or empty, all names
             are shown. If nonempty, only the names that are in <only>
             are shown.
       omit_zero: if True, only nonzero entries are shown.
       rounder: a MinutesRounder(<nr_of_minutes_to_round_to>) instance.
             If None, timings are shown exactly as they are. If a rounder
             instance is passed, its round(name, minutes) function will
             be used to display timings rounded to, e.g., quarter hours when
             you pass a MinutesRounder(15).
       clear_rounder: If you want to continue a previous surplus, pass
             False here. Otherwise, the rounder instance is cleared of
             previous surplus, to have clean rounding within these totals.
    '''
    items = []
    seen = set()

    for name, minutes in self.iteritems():
      if omit_zero and minutes == 0:
        continue
      if (not only) or (name in only):
        items.append([name, minutes])
        seen.add(name)
    
    if only and not omit_zero:
      for name in only:
        if not name in seen:
          items.append([name, 0])
          seen.add(name)

    items = sorted(items)
    if rounder and rounder.enabled:
      if clear_rounder:
        rounder.clear_surplus()
      for item in items:
        name, minutes = item
        item[1] = rounder.round(name, minutes)

    if flat:
      def total2str(name, minutes, always_show_sign=False):
        mins_str = mins2str(minutes, always_show_sign)
        if not ':' in mins_str:
          mins_str += '   '
        mins_str = '%9s' % mins_str
        return msgs2str(mins_str, ' ', name)

      out = []
      grand_total = 0
      for name, minutes in items:
        grand_total += minutes
        out.append(total2str(name, minutes))

      out.append('    =====')
      out.append(total2str('', grand_total, True))

    else:
      OWN = '^own'
      OWNSTR = '^ownstr'
      SUMSTR = '^sumstr'
      TIME_LEN = '^time_len'
      
      groups = {}
      for name,val in items:
        path = name.split('.')
        d = groups
        for parent in path[:-1]:
          if not parent in d:
            d[parent] = {}
          d = d[parent]
        last_name = path[-1]
        assert(last_name not in d)
        val_d = {}
        if val:
          val_d[OWN] = val
          val_d[OWNSTR] = mins2str(val)
        d[last_name] = val_d

      def trickle_sums(a_dict, full_name='', last_name=None):
        own_minutes = a_dict.get(OWN) or 0
        minutes_sum = own_minutes
        for child_name, child_dict in a_dict.iteritems():
          if child_name[0] == '^':
            continue
          if full_name:
            child_full_name = '.'.join((full_name, child_name))
          else:
            child_full_name = child_name
          sub_sum = trickle_sums(child_dict,
                                 full_name=child_full_name,
                                 last_name=child_name)
          minutes_sum += sub_sum
        a_dict[SUMSTR] = mins2str(minutes_sum)
        return minutes_sum
      #end of trickle_sums()

      grand_total = trickle_sums(groups)

      def compose_print(a_dict, full_name='', last_name=None, indent=0):
        lines = []
        own_hours = a_dict.get(OWNSTR) or ''
        group_sum = a_dict.get(SUMSTR) or '0'

        own_same_as_group = (own_hours == group_sum)

        has_minutes = False

        for child_name, child_dict in a_dict.iteritems():
          if child_name[0] == '^':
            continue
          sum_str = child_dict.get(SUMSTR) or ''
          if ':' in sum_str:
            has_minutes = True
            break

        if own_hours and has_minutes and (':' not in own_hours):
          own_hours += ':  '
        max_len = len(own_hours)

        for child_name, child_dict in a_dict.iteritems():
          if child_name[0] == '^':
            continue
          sum_str = child_dict.get(SUMSTR) or ''
          if has_minutes and (':' not in sum_str):
            sum_str += ':  '
            child_dict[SUMSTR] = sum_str
          max_len = max(max_len, len(sum_str))

        if not last_name:
          # preparing for printing grand total below
          if not group_sum.startswith('-'):
            group_sum = '+' + group_sum
          max_len = max(max_len, len(group_sum))

        len_fmt = r'%' + str(max_len) + 's'

        if own_hours and (not own_same_as_group):
          lines.append(msgs2str(' ' * indent, len_fmt % own_hours, ' ^'))
        
        child_indent = indent + max_len + 1

        for child_name, child_dict in sorted(a_dict.iteritems()):
          if child_name[0] == '^':
            continue

          if full_name:
            child_full_name = '.'.join((full_name, child_name))
          else:
            child_full_name = child_name
          
          child_sum = child_dict.get(SUMSTR) or '0'

          lines.append(msgs2str(
              ' ' * indent,
              len_fmt % child_sum, ' ', child_name))
          
          lines.extend(compose_print(child_dict,
                                     child_full_name,
                                     child_name,
                                     child_indent))
        if not last_name:
          total_str = len_fmt % group_sum
          lines.append(msgs2str(' '*indent, '=' * (len(total_str))))
          lines.append(msgs2str(' '*indent, total_str))
        return lines
      #end of compose_print()

      out = compose_print(groups, indent=1)

    return '\n'.join(out)

  def __str__(self):
    return self.to_string(None)

  def find_full_names(self, name):
    with_children = False
    only_children = False
    if name.endswith('*'):
      name = name[:-1]
      with_children = True
      if name.endswith('.'):
        name = name[:-1]
        only_children = True
        
    Timelog.validate_name(name)

    matches = set()
    if (not only_children) and (name in self.entries):
      matches.add(name)

    name_dot = name + '.'
    dot_name_dot = '.' + name_dot
    dot_name = '.' + name

    for known_name in self.entries:
      if known_name.startswith(name_dot):
        matches.add(name)
      elif known_name.endswith(dot_name):
        matches.add(known_name)
      else:
        start = 0
        l = len(known_name)
        while start < l:
          pos = known_name.find(dot_name_dot, start)
          if pos < 0:
            break
          matches.add(known_name[:pos + len(dot_name)])
          start = pos + len(dot_name)

    if with_children:
      children = set()
      for name in matches:
        children.update(self.find_all_children(name))

      if only_children:
        matches = children
      else:
        matches.update(children)

    return matches

  def find_full_name(self, name):
    matches = self.find_full_names(name)
    if name in matches:
      return name
    if len(matches) > 1:
      raise Totals.TotalsErr("Multiple matches found for '", name, "':\n",
             '\n'.join([('- ' + m) for m in sorted(matches)]))
    elif len(matches) == 1:
      return matches.pop()
    else:
      return None

  def name_exists(self, name):
    matches = self.find_full_names(name)
    if name in matches:
      return True
    return False

  def find_all_children(self, name):
    Timelog.validate_name(name)
    children = []
    for known_name in self.entries:
      if known_name.startswith(name) and known_name != name:
        children.append(known_name)
    return children

  def rename(self, from_name, to_name, ensure_presence=False):
    assert(to_name not in self.entries)
    modified = False
    keys = self.entries.keys()
    # ^ just to illustrate that the keys list stays unmodified.
    for k in keys:
      new_k = Timing._rename_str(k, from_name, to_name)
      if new_k:
        self.entries[new_k] = self.entries[k]
        del self.entries[k]
        modified = True
    if modified and ensure_presence:
      # if this moved a child away, the parent should still exist.
      parent_name = '.'.join(from_name.split('.')[:-1])
      if parent_name and not self.name_exists(parent_name):
        self.entries[parent_name] = 0
    if modified:
      self.modified = True
    return modified

  def forget(self, name, ensure_presence=False):
    modified = False
    if name in self.entries:
      del self.entries[name]
      modified = True
    if modified and ensure_presence:
      # if this eliminated a child, the parent should still exist.
      parent_name = '.'.join(name.split('.')[:-1])
      if parent_name and not self.name_exists(parent_name):
        self.entries[parent_name] = 0
    if modified:
      self.modified = True
    return modified


class Timelog(Notify):
  FIX_OVERLAPS_SHIFT = 1
  FIX_OVERLAPS_DROP = 2
  FIX_OVERLAPS_IGNORE = 3

  def __init__(self, notify_func, timelog_dir):
    Notify.__init__(self, notify_func)
    self.timelog_dir = timelog_dir
    self.totals_path = j(self.timelog_dir, 'totals')
    self.clear()

  def clear(self):
    self.timelog_files = {}

  class InvalidNameError(Error):
    pass

  @staticmethod
  def validate_name(name, allow_multiple_names=False):
    if allow_multiple_names:
      regex = NAMES_STR_RE
    else:
      regex = NAME_STR_RE
    if not Regex.match(regex, name):
      raise Timelog.InvalidNameError(
               "Invalid name: '", name, "'\n",
               name_syntax_docstr)

  def get_totals(self):
    return Totals(self.totals_path)

  def add_name(self, name):
    Timelog.validate_name(name)
    t = self.get_totals()
    t.add_name(name)
    t.save()

  def add_timing(self, timing, directly_to_file=True):
    assert(timing.started and timing.name)
    yearnr = time2year(timing.started)
    timings_file = self.get_timings_for_year(yearnr)
    timings_file.add_timing(timing, directly_to_file=directly_to_file)
    t = self.get_totals()
    t.add_timing(timing)
    if directly_to_file:
      t.save()
    return timings_file

  def remove_timing(self, timing):
    yearnr = time2year(timing.started)
    year = self.get_timings_for_year(yearnr)
    year.remove_timing(timing)
    year.save()
    totals = self.get_totals()
    totals.remove_timing(timing)
    totals.save()
    if yearnr != time2year(now()):
      self.notify(Notify.FIX_NEEDED, yearnr)

  def find_last_tickoff(self):
    yearnrs = self.get_available_years()
    found = None
    for yearnr in reversed(yearnrs):
      year = self.get_timings_for_year(yearnr)
      for t in reversed(year.timings):
        if t.started and (t.minutes < 0):
          found = t
          break
      if found:
        break
    return found
    
  def rename(self, from_name, to_name):
    totals = self.get_totals()

    if totals.name_exists(to_name):
      _raise("cannot rename, target name already exists: '", to_name, "'")

    if not totals.name_exists(from_name):
      from_full_names = totals.find_full_names(from_name)
      if not from_full_names:
        _raise("I don't know the name '", from_name, "'")
      _raise('you must supply a full name to rename. How about:',
             ''.join(['\ntim rename "%s" "%s"' % (f, to_name)
                      for f in from_full_names]))

    Timelog.validate_name(to_name)

    assert(from_name != to_name)

    # alright.

    from_dot = from_name + '.'

    available_years = sorted(self.get_available_years())
    for yearnr in available_years:
      tf = self.get_timings_for_year(yearnr)
      tf.rename(from_name, to_name)
      if tf.modified:
        tf.save()

    totals.rename(from_name, to_name, ensure_presence=True)
    if totals.modified:
      totals.save()

  def forget(self, name, path):
    modified = False
    forgotten_timings = Timelog.TimingsFile(self.notify_func, path, read=False)
    yearnrs = self.get_available_years()
    for yearnr in yearnrs:
      year = self.get_timings_for_year(yearnr)
      if not year.exists:
        continue
      forgotten_timings.add_timings( year.forget(name) )
      if forgotten_timings.modified:
        modified = True
        forgotten_timings.save()
      if year.modified:
        modified = True
        year.save()

    totals = self.get_totals()
    totals.forget(name, ensure_presence=True)
    if totals.modified:
      modified = True
      totals.save()

    return modified

  def recall(self, timings_path, as_name=None, do_add=False):
    forgotten_timings = Timelog.TimingsFile(self.notify_func, timings_path)
    if not forgotten_timings.exists:
      _raise("no such forgotten file: '", timings_path, "'")

    if not do_add:
      totals = self.get_totals()
      names = set([t.name for t in forgotten_timings.timings])
      if as_name:
        if len(names) > 1:
          _raise('thwarting attempt to add several timing names as a single ',
                 "other. You supplied 'as ", as_name, "', and the file ",
                 'contains: ', ', '.join(sorted(names)))
        names = [as_name]

      if any([totals.name_exists(name) for name in names]):
        _raise("cannot recall timings, name already exists: '", name, "'")

    modified = False
    self.timelog_files = {}
    for t in forgotten_timings.timings:
      if as_name:
        t.name = as_name
      self.add_timing(t)
      modified = True
    self.fix()
    return modified

  class TimingsFile(Notify):
    def __init__(self, notify_func, path, read=True):
      Notify.__init__(self, notify_func)
      self.path = path
      self.timings = None
      self.totals = None
      self.initial_totals = None
      self.exists = None
      self.modified = None
      self.valid = True
      if read:
        self.read()
      else:
        self.timings = []
        self.initial_totals = Totals()
        self.totals = Totals()
        self.exists = False

    def read(self):
      self.exists = False
      self.modified = False
      try:
        lf = open(self.path, "r")
        self.exists = True
      except IOError as e:
        if e.errno == errno.ENOENT:
          self.timings = []
          self.initial_totals = Totals()
          self.totals = Totals()
          self.exists = False
          return
        raise

      try:
        self.valid = False
        self.timings = []
        self.initial_totals = Totals()

        line_nr = 0

        # read initial totals
        while True:
          at = lf.tell()
          line = lf.readline()
          line_nr += 1
          match = Regex.match(LOG_INITIAL_TOTAL_RE, line)
          if match:
            total_string = match.group(1)
            self.initial_totals.deserialize(total_string)
          else:
            # done with initial totals.
            # unread last line, continue below.
            lf.seek(at)
            line_nr -= 1
            break

        self.totals = self.initial_totals.copy()

        while True:
          line = lf.readline()
          line_nr += 1
          if not line:
            break

          t = Timing().deserialize(line)
          if not t:
            _raise('cannot parse line ', line_nr, ' in timelog file ', 
                   self.path)
          self.timings.append(t)

        self.update_totals()
        self.valid = True
        self.modified = False

      finally:
        lf.close()

    def update_totals(self):
      totals = Totals()
      totals.set_to(self.initial_totals)
      for t in self.timings:
        totals.add_timing(t)
      if not self.modified:
        if totals != self.totals:
          self.modified = True
      self.totals = totals

    def set_initial_totals(self, initial_totals):
      if self.initial_totals is None:
        self.initial_totals = Totals()
      if not self.modified:
        if self.initial_totals != initial_totals:
          self.modified = True
      self.initial_totals.set_to(initial_totals)

    def add_timing(self, timing, directly_to_file=False):
      assert(isinstance(timing, Timing))
      if timing.minutes == 0:
        return
      self.timings.append(timing)
      self.update_totals()
      if directly_to_file:
        append_to_file(self.path, timing.serialize())
      else:
        self.modified = True

    def add_timings(self, timings, directly_to_file=False):
      for t in timings:
        self.add_timing(t, directly_to_file)

    def remove_timing(self, timing):
      matches = [i for i,t in enumerate(self.timings)
                 if t.matches(timing)]
      l = len(matches)
      if l < 1:
        _raise('Cannot remove timing: start date ',
               time2str(timing.started), ' not found in ', self.path)
      if l > 1:
        _raise('Cannot remove timing: multiple matches found in ',
               self.path, ' for ', repr(timing))
      match_idx = matches[0]
      del self.timings[match_idx]
      self.modified = True

    def save(self):
      if not self.valid:
        _raise('Not saving invalid timings file.')
      lines = [ ' '.join((INITIAL_TOTAL_KEYWORD, line))
                for line in self.initial_totals.get_serialized_items() ]
      lines.extend([ t.serialize() for t in self.timings ])
      write_file(self.path, ''.join(lines))
      self.modified = False

    def sort(self):
      new = sorted(self.timings)
      if new != self.timings:
        self.timings = new
        self.modified = True

    def rename(self, from_name, to_name):
      for t in self.timings:
        if t.rename(from_name, to_name):
          self.modified = True
      if self.initial_totals:
        if self.initial_totals.rename(from_name, to_name):
          self.modified = True
      if self.totals:
        if self.totals.rename(from_name, to_name):
          self.modified = True

    def forget(self, name):
      l = len(self.timings)
      new_timings = []
      forgotten_timings = []
      for t in self.timings:
        if name == t.name:
          forgotten_timings.append(t)
        else:
          new_timings.append(t)

      if forgotten_timings:
        self.timings = new_timings
        self.modified = True
      if self.initial_totals:
        if self.initial_totals.forget(name):
          self.modified = True
      if self.totals:
        if self.totals.forget(name):
          self.modified = True
      return forgotten_timings
  #end of TimingsFile

  def path_for_year(self, year):
    return j(self.timelog_dir, str(int(year)))

  def get_timings_for_year(self, year=None):
    'return a TimingsFile instance for the given year number.'
    if year is None:
      year = time2year(now())
    year = int(year)
    timings_file = self.timelog_files.get(year)
    if not timings_file:
      timings_file = Timelog.TimingsFile(self.notify_func,
                                         self.path_for_year(year))
      self.timelog_files[year] = timings_file
      timings_file.read()
    return timings_file
    
  def get_available_years(self):
    'returns a list of integers with year numbers for which log files exist.'
    files = os.listdir(self.timelog_dir)
    return [int(name) for name in files
            if name.isdigit() and os.path.isfile(j(self.timelog_dir, name))]

  def fix(self, start_year=None, clear_initial_totals=False,
          fix_overlaps=None):
    unfixed = 0
    fixed = 0

    if start_year:
      start_year = int(start_year)

    years_available = self.get_available_years()
    if start_year is None:
      start_year = min(years_available)
    elif start_year not in years_available:
      _raise('No record for ', start_year)
    else:
      start_year = max(min(years_available), start_year)
    years_available = range(start_year, max(years_available)+1)

    unfixed, fixed = self._fix_timings_in_wrong_years(years_available)
    u2, f2 = self._fix_sorting(years_available)
    unfixed += u2
    fixed += f2

    while True:
      u2, f2 = self._fix_overlaps(years_available, 
                      fix_overlaps=fix_overlaps)
      unfixed += u2
      fixed += f2
      if not f2:
        break
      # do this again, without counting fixes
      self._fix_timings_in_wrong_years(years_available)
      self._fix_sorting(years_available)

    u2, f2 = self._fix_totals(years_available, clear_initial_totals)
    unfixed += u2
    fixed += f2
    if (fixed < 1) and (unfixed < 1):
      self.msg('All correct.')
    else:
      if fixed:
        self.msg('Errors fixed: ', fixed)
      if unfixed:
        self.warn('Unfixed errors: ', unfixed)
    return fixed

  def _fix_timings_in_wrong_years(self, yearnrs):
    '''check individual entries, sort them into the correct files.'''
    fixed = 0
    unfixed = 0

    entries_in_wrong_file = {}

    for yearnr in yearnrs:
      year = self.get_timings_for_year(yearnr)

      wrong_here = {}
      for t in year.timings:
        started_year = t.started_year()
        if yearnr != started_year:
          wrong_timings = wrong_here.get(started_year)
          if wrong_timings is None:
            wrong_timings = []
            wrong_here[started_year] = wrong_timings
          wrong_timings.append(t)

      if wrong_here:
        count = sum([len(timings_list)
                     for k,timings_list in wrong_here.iteritems()])
        self.msg('** removing ', count, ' wrong timings from ', yearnr, ':')
        for k,timings_list in wrong_here.iteritems():
          for t in timings_list:
            year.remove_timing(t)
            self.msg('    ', repr(t))

          wrong_timings = entries_in_wrong_file.get(k)
          if wrong_timings is None:
            wrong_timings = []
            entries_in_wrong_file[k] = wrong_timings
          wrong_timings.extend(timings_list)

      if year.modified:
        year.save()


    for yearnr,timings in entries_in_wrong_file.iteritems():
      self.msg('++ adding ', len(timings), ' timings to ', yearnr)
      year = self.get_timings_for_year(yearnr)
      for t in timings:
        year.add_timing(t)
        self.msg('    ', repr(t))
        fixed += 1
      if year.modified:
        year.save()

    return unfixed, fixed

  def _fix_sorting(self, yearnrs):
    fixed = 0
    unfixed = 0
    for yearnr in yearnrs:
      year = self.get_timings_for_year(yearnr)
      year.sort()
      if year.modified:
        self.msg('** sorted entries in ', yearnr)
        fixed += 1
        year.save()
    return unfixed, fixed

  def _fix_overlaps(self, yearnrs, fix_overlaps=None):
    fixed = 0
    unfixed = 0
    for yearnr in yearnrs:
      year = self.get_timings_for_year(yearnr)
      prev = None
      for t in year.timings:
        if prev:
          prev_until = prev.started + 60 * prev.minutes 
        else:
          prev_until = None
        was_fixed = False
        if (prev_until > t.started) and (
            fix_overlaps != Timelog.FIX_OVERLAPS_IGNORE):
          t_was = repr(t)
          verbose = True
          overlap = prev_until - t.started
          if fix_overlaps == Timelog.FIX_OVERLAPS_SHIFT:
            msg = 'shifted '
            t.started = prev_until
            year.modified = True
            fixed += 1
            was_fixed = True
          elif fix_overlaps == Timelog.FIX_OVERLAPS_DROP:
            msg = 'dropped '
            t.minutes -= overlap / 60
            if t.minutes < 0:
              t.minutes = 0
            t.started = prev_until
            year.modified = True
            fixed += 1
            was_fixed = True
          else:
            unfixed += 1
            msg = 'NOT FIXING: '
          
          if verbose:
            if prev_was_fixed:
              prev_fixed_str = ' after above fix'
            else:
              prev_fixed_str = ''
            hours_str = mins2str(float(overlap)/60)
            if not ':' in hours_str:
              hours_str += ':00'
            self.msg('** ', msg, 'overlap:',
                     '\n      ', repr(prev),
                     #        YYYY-MM-DD HH:MM
                     '\n          (until %5s' % time2str(prev_until, fmt='%H:%M'),
                        prev_fixed_str, ')'
                     '\n  and ', t_was,
                     '\n     (overlap by %5s)' % hours_str)
            if was_fixed:
              self.msg('  --> ', repr(t))
        prev = t
        prev_was_fixed = was_fixed

      if year.modified:
        year.save()
        year.update_totals()
    if unfixed:
      self.msg("(see --overlaps=... option in 'tim help fix' to fix overlaps)")
    return unfixed, fixed

  def _fix_totals(self, yearnrs, clear_initial_totals):
    fixed = 0
    unfixed = 0

    def diff_totals(t_is, t_shouldbe):
      diff = []
      for name, minutes in sorted(t_is.iteritems()):
        shouldbe_minutes = t_shouldbe.get(name)
        if (shouldbe_minutes != minutes) and not (
             (shouldbe_minutes or 0) == (minutes or 0)):
          if shouldbe_minutes is None:
            shouldbe_str = ', but there is no prior record of that name.'
          else:
            shouldbe_str = ', should be ' + mins2str(shouldbe_minutes)
          diff.append(msgs2str(" - '", name, "' is ", mins2str(minutes),
                               shouldbe_str))
      for name,minutes in sorted(t_shouldbe.iteritems()):
        if not name in t_is:
          diff.append(msgs2str(" - '", name, "' is missing, should be ",
                               mins2str(minutes)))
      return diff

    prev_totals = None

    for yearnr in yearnrs:
      year = self.get_timings_for_year(yearnr)
      if not year.exists:
        self.warn('No log for ', yearnr)

      year.update_totals()

      changed_initial_totals = False

      if (not prev_totals) and (not year.initial_totals.is_empty()):
        if clear_initial_totals:
          save_path = j(os.path.dirname(year.path),
                        'initial_totals_of_' + os.path.basename(year.path)
                        + '_removed_at_' + filename_timestamp())
          self.msg('** clearing initial totals of ', yearnr, '\n',
                   '** saving to: ', save_path)
          write_file(save_path, repr(year.initial_totals))
          year.initial_totals.clear()
          changed_initial_totals = True
          fixed += 1
        elif yearnr == yearnrs[0]:
          unfixed += 1
          self.warn('NOT FIXING: ', yearnr, ' is the first year on record, ',
                    'but it has initial totals:\n',
                    '\n'.join([ ('*** ' + line) 
                                for line in
                                str(year.initial_totals).split('\n')]))
        else:
          self.msg('Starting off with initial totals of ', yearnr)
        
      elif prev_totals:
        diff = diff_totals(year.initial_totals, prev_totals)
        if diff:
          self.msg('** fixing: the initial totals in ', yearnr, ' are wrong.')
          self.msg('\n'.join(diff))
          year.set_initial_totals(prev_totals)
          changed_initial_totals = True
          fixed += 1

      if changed_initial_totals:
        year.update_totals()
        year.save()

      prev_totals = year.totals
      
    # finally, update the current grand totals to the last totals seen
    if prev_totals:
      totals = self.get_totals()
      diff = diff_totals(totals, prev_totals)
      if diff:
        self.msg('** fixing: the grand totals are wrong.')
        self.msg('\n'.join(diff))
        totals.set_to(prev_totals)
        totals.save()
        fixed += 1

    return unfixed, fixed


  class QueryErr(Error):
    pass


  class Query:
    def __init__(self, unit=None, amount=None, start=None, end=None,
                 snap_to_calendar=None, include_end=None, include_start=None,
                 round_to_minutes=None, sum_unit=None, sum_amount=None,
                 group=None, only=None, flat=None):
      '''unit: a UNIT_* constant.
         amount: a float number.
         start: a start date in unix time (seconds since epoch), inclusive.
         end: a date like in start, inclusive.
         snap_to_calendar: if True, amount is reduced to start with a
           beginning of the <unit> (week, month...).
      '''
      self.unit = unit
      self.amount = amount
      self.start = start
      self.end = end
      self.snap_to_calendar = snap_to_calendar
      self.include_start = include_start
      self.include_end = include_end
      self.round_to_minutes = round_to_minutes
      self.sum_unit = sum_unit
      self.group = group
      self.only = only
      self.flat = flat

  class QueryResult:
    def __init__(self):
      self.timings = []
      self.totals = Totals()
      self.from_query = None
      # the following are not the exact values from the Query instance.
      # They may me filled up with defaults or matched up with reality...
      self.start = None
      self.end = None
      self.include_start = None
      self.include_end = None
      self.unit = None
      self.amount = None
      self.snap_to_calendar = None
      self.group = None
      self.rounder = None
      self.flat = None
      self.only = None

    def totals_string(self):
      return self.totals.to_string(flat=self.flat, rounder=self.rounder)

    def description_str(self):
      lines = []

      tokens = []
      if self.unit:
        unit_phrase = Timelog.QueryPhrase.unit_phrase_for(self.unit)

      if self.amount and self.unit:
        amount = self.amount
        amount_frac, amount_int = math.modf(amount)
        if amount_frac == 0.0:
          s = str(int(amount_int))
        else:
          s = str(amount_int)
        tokens.append(' '.join((s, unit_phrase,)))

      if self.from_query:
        q = self.from_query
        if q.start:
          if self.snap_to_calendar:
            s = 'around '
          else:
            s = 'at '
          tokens.append(msgs2str('starting ', s, time2str(q.start)))

        if q.end:
          if not q.include_end:
            s = 'before '
          else:
            if self.snap_to_calendar:
              s = 'around '
            else:
              s = ''
          tokens.append(msgs2str('ending ', s, time2str(q.end)))

        if (q.start is None) and (q.end is None):
          if q.snap_to_calendar:
            s = 'around '
          else:
            s = ''
          tokens.append(msgs2str('ending ', s, 'now'))

        if self.snap_to_calendar and self.unit:
          tokens.append(msgs2str('showing entire ', unit_phrase))
        elif not self.snap_to_calendar:
          tokens.append('exactly')

      if tokens:
        lines.append(msgs2str(', '.join(tokens), '.'))

      lines.append(msgs2str(
           time2weekdaystr(self.start), ' ', time2str(self.start),
           ' ... ',
           time2weekdaystr(self.end), ' ', time2str(self.end), ':'))

      return '\n'.join(lines)

    def add_timing(self, timing):
      self.timings.append(timing)
      self.totals.add_timing(timing)

    def __repr__(self):
      return ''.join(('[', ','.join((repr(self.timings), repr(self.totals),)),
                      ']',))
    def __str__(self):
      return repr(self)

  class QueryPhrase(Query):
    unit_phrases = {
        'hours' : UNIT_HOUR,
        'days' : UNIT_DAY,
        'weeks' : UNIT_WEEK,
        'months' : UNIT_MONTH,
        'years' : UNIT_YEAR,
      } 

    @staticmethod
    def unit_phrase_for(unit_id):
      r = [phrase
           for phrase,unit in Timelog.QueryPhrase.unit_phrases.iteritems()
           if unit_id == unit]
      if len(r) != 1:
        return None
      return r[0]

    def __init__(self, tokens):
      Timelog.Query.__init__(self)
      self.tokens = tokens

      self.l = len(tokens)
      self.i = -1
      self.token = None

      self.parse()

    @staticmethod
    def parse_date_str(string):
      s = string
      y = None
      mo = None
      d = None
      h = None
      mi = None
      w = None
      while True:
        l = len(s)
        if not l:
          break

        y_end = 0
        while (y_end < l) and s[y_end].isdigit():
          y_end += 1

        if y_end:
          y = int(s[:y_end])
          s = s[y_end:]
          continue

        if s.startswith('-W'):
          w = int(s[2:])
          break
        if s.startswith('W'):
          w = int(s[1:])
          break

        if s.startswith('-'):
          parts = s[1:].split('-')
          nrs = parts[:-1]
          last_part_digits = 0
          last_part = parts[-1]
          l = len(last_part)
          while (last_part_digits < l) and last_part[last_part_digits].isdigit():
            last_part_digits += 1
          nrs.append(last_part[:last_part_digits])
          s = last_part[last_part_digits:]

          l = len(nrs)
          if l >= 1:
            mo = int(nrs[0])
            if l == 2:
              d = int(nrs[1])
            elif l > 2:
              _raise("Too many dashes '-' in date: '", string, "'")
          continue

        if s.startswith('_') or s.startswith(' '):
          hm = s[1:].split(':')
          if not hm[-1].isdigit():
            _raise("Too much information in date: '", string, "'")

          if len(hm) >= 1:
            h = int(hm[0])
            if len(hm) == 2:
              m = int(hm[1])
            elif len(hm) > 2:
              _raise("Too many colons ':' in date: '", string, "'")
          break

        _raise("Expected a date, got '", string, '"')

      n = time.localtime()

      if not y:
        y = n.tm_year
        if not mo:
          mo = n.tm_mon
          if not d:
            d = n.tm_mday
            if not h:
              h = n.tm_hour
              if not mi:
                mi = n.tm_min
            else:
              # h given
              if not mi:
                mi = 0
          else:
            # day given
            if not h:
              h = 0
            if not mi:
              mi = 0
        else:
          # month given
          if not d:
            d = 1
          if not h:
            h = 0
          if not mi:
            mi = 0
      else:
        # year given
        if not mo:
          mo = 1
        if not d:
          d = 1
        if not h:
          h = 0
        if not mi:
          mi = 0

      year_str = str(y)
      if len(year_str) < 4:
        year_str = ('0' * (4-len(year_str))) + year_str

      if w:
        return str2time(year_str + ' ' + str(w) + ' 1', fmt='%Y %W %w')

      return str2time(
        year_str + '-' + str(mo) + '-' + str(d) + ' '
        + str(h) + ':' + str(mi))

    def next_arg(self):
      if (self.i + 1) >= self.l:
        return False
      self.i += 1
      self.token = self.tokens[self.i]
      return True

    def prev_arg(self):
      if self.i <= 0:
        return False
      self.i -= 1
      self.token = self.tokens[self.i]
      return True

    def expect_arg(self, name):
      self.next_arg()
      if self.i >= self.l:
        self.err('Missing ', name, ' argument at end of arguments')

    def next_date_arg(self):
      self.expect_arg('date')
      return self.date_arg(do_raise=True)

    def date_arg(self, do_raise=False):
      try:
        return self.parse_date_str(self.token)
      except Error:
        if do_raise:
          raise
        return None

    def unit_arg(self):
      for phrase, phrase_unit in Timelog.QueryPhrase.unit_phrases.iteritems():
        if phrase.startswith(self.token):
          return phrase_unit
      return None

    def minutes_arg(self):
      minutes = str2mins(self.token, raise_on_err=False)
      if minutes is None:
        return None
      return float(minutes)

    def nr_arg(self):
      m = self.minutes_arg()
      if m is None:
        return None
      return m / 60

    def namelist_arg(self):
      return self.token.split(',')

    def superfluous(self, name, val):
      if val is not None:
        self.err('Too much: ', name)

    def err(self, *msgs):
      raise Timelog.QueryErr(msgs2str(*msgs), ": '", self.token,
                     "' (word ", self.i+1, ')')
      
    def parse(self):
      while self.next_arg():
        arg_unit = self.unit_arg()
        if arg_unit:
          self.superfluous("unit '" + 
                             Timelog.QueryPhrase.unit_phrase_for(arg_unit)
                             + "'",
                           self.unit)
          self.unit = arg_unit
        elif '-f' == self.token:
          self.flat = True
        elif 'exactly'.startswith(self.token):
          self.superfluous("'exactly' keyword", self.snap_to_calendar)
          self.snap_to_calendar = False
        elif 'from'.startswith(self.token):
          self.superfluous("start indicator 'from'", self.start)
          self.start = self.next_date_arg()
          self.include_start = True
        elif 'until'.startswith(self.token):
          self.superfluous("end indicator 'until'", self.end)
          self.end = self.next_date_arg()
          self.include_end = True
        elif 'after'.startswith(self.token):
          self.superfluous("start indicator 'after'", self.start)
          self.start = self.next_date_arg()
          self.include_start = False
        elif 'before'.startswith(self.token):
          self.superfluous("end indicator 'before'", self.end)
          self.end = self.next_date_arg()
          self.include_end = False
        elif 'sum'.startswith(self.token):
          self.superfluous('sum request', self.sum_unit)
          self.next_arg()
          self.sum_unit = self.unit_arg()
          if not self.sum_unit:
            self.sum_amount = self.nr_arg()
            if self.sum_amount is None:
              self.err('Expecting number or time unit')
            self.next_arg()
            self.sum_unit = self.unit_arg()
            if self.sum_unit is None:
              self.err('Expecting time unit')
          else:
            self.sum_amount = 1
          self.err('sum not implemented')
        elif 'only'.startswith(self.token):
          self.superfluous("'only' argument", self.only)
          self.next_arg()
          self.only = self.namelist_arg()
        elif 'round'.startswith(self.token):
          self.superfluous("'round' argument", self.round_to_minutes)
          self.expect_arg('rounding step')
          self.round_to_minutes = self.minutes_arg()
        else:
          date = None
          nr = None
          if (self.amount is not None) or (self.unit is not None) and (
              self.start == None or self.end == None):
            # This can be a date. Be a bit magic about this one.
            date = self.date_arg()
          if date is None:
            nr = self.nr_arg()

          if date is not None:
            if self.start is None:
              self.start = date
            elif self.end is None:
              self.end = date
            else:
              self.superfluous('date', True)
          elif nr is not None:
            self.superfluous('number', self.amount)
            self.amount = nr
          else:
            self.err('Invalid argument')


  def run_query_phrase(self, phrase_tokens):
    return self.run_query( Timelog.QueryPhrase(phrase_tokens) )

  def run_query(self, query):
    '''query: a Timelog.Query instance describing the search request.
       returns: a Timelog.QueryResult instance with .timings and .totals
                populated according to the query.'''
    start = query.start
    end = query.end
    amount = query.amount
    unit = query.unit
    include_start = query.include_start
    include_end = query.include_end
    snap_to_calendar = query.snap_to_calendar

    # defaults
    if (start is None) and (end is None):
      end = now()
    if (start is None) or (end is None):
      if amount is None:
        amount = 1.0
    if snap_to_calendar is None:
      snap_to_calendar = True
    if unit is None:
      unit = UNIT_WEEK
    if include_start is None:
      include_start = True
    if include_end is None:
      include_end = True

    # validate: exactly two values of start, end, amount must be supplied.
    supplied_count = 0
    for b in (start, end, amount):
      if b is not None:
        supplied_count += 1
    if supplied_count != 2:
      if supplied_count < 2:
        word = 'few'
      else:
        word = 'many'
      raise Timelog.QueryErr('Too ', word, ' values. ',
       'Any two of start, end or amount must be given, ',
       'while the third must be omitted.')
    
    amount = abs(amount)

    if snap_to_calendar:
      if start is not None:
        if include_start:
          start = date_beginning_of(unit, start)
        else:
          start = date_end_of(unit, start)
      if end is not None:
        if include_end:
          end = date_end_of(unit, end)
          if end < query.end:
            end = query.end
        else:
          end = date_beginning_of(unit, end)

    if end is None:
      end = date_add(amount, unit, start)
    elif start is None:
      start = date_subtract(amount, unit, end)

    end -= 1e-6 # show the last minute of the previous <unit>
      
    only = None
    if query.only:
      only = []
      totals = self.get_totals()
      for name in query.only:
        only.extend(totals.find_full_names(name))

    query_result = self.get_entries(start, end, include_start, include_end,
                                    only)

    # enrich result with information about the values queried
    query_result.from_query = query
    query_result.unit = unit
    query_result.amount = amount
    query_result.snap_to_calendar = snap_to_calendar
    
    query_result.flat = query.flat

    if query.round_to_minutes:
      query_result.rounder = MinutesRounder(query.round_to_minutes)

    return query_result


  def get_entries(self, start_date, end_date, include_start, include_end,
                  only=None):
    if start_date > end_date:
      _raise('Start date is later than end date: ',
             time2str(start_date) , ' > ', time2str(end_date), '.')
    #  x = start_date
    #  start_date = end_date
    #  end_date = x
    #  x = include_start
    #  include_start = include_end
    #  include_end = x

    y = time2year(start_date)
    end_year = time2year(end_date)

    result = Timelog.QueryResult()
    result.start = start_date
    result.end = end_date
    result.include_start = include_start
    result.include_end = include_end
    result.only = only

    while y <= end_year:
      year = self.get_timings_for_year(y)
      for timing in year.timings:
        if only and not (timing.name in only):
          continue
        if (((timing.started > start_date)
             or
             (include_start and (timing.started == start_date)))
            and
            ((timing.started < end_date)
             or
             (include_end and (timing.started == end_date)))
           ):
          result.add_timing(timing)
      y += 1

    # just for looks
    if not include_end:
      result.end -= 1
    if not include_start:
      result.start += 1
    return result


    


class TimedDirLock(Notify):
  id_count = 0

  def __init__(self, notify_func, lock_path,
               sleep_time_in_seconds=1.0, timeout=30, valid_for=10):
    Notify.__init__(self, notify_func)
    self.lock = self.__enter__
    self.unlock = self.__exit__
    self.lock_path = lock_path
    self.sleep_time_in_seconds = sleep_time_in_seconds
    self.timeout = timeout
    self.valid_for = valid_for
    self.acquired = None
    self.id_file = j(self.lock_path, 'pid')
    self.id = TimedDirLock.id_count
    TimedDirLock.id_count += 1
    self.lock_count = 0


  class LockError(Error):
    pass

  def get_lock_creation_time(self):
    try:
      return os.path.getmtime(self.lock_path)
    except OSError as e:
      if e.errno == errno.ENOENT:
        return None
      raise

  def remove_stale_lock(self, kill_process=True):
    at = self.get_lock_creation_time()
    pid = None
    if (at is not None) and (now() - int(at) > self.valid_for):
      self.msg("Removing stale lock '%s'" % self.lock_path)
      if not gently_kill_process(self.locked_by_pid()):
        raise TimedDirLock.LockError(
                'Unable to kill locking process (', pid, ')')

      # process is gone. Remove the lock files.
      try:
        shutil.rmtree( self.lock_path )
      except OSError as e:
        if e.errno != errno.ENOENT:
          raise
    return pid

  def __enter__(self):
    if self.acquired:
      self.lock_count += 1
      return
    dirname = os.path.dirname(self.lock_path)
    if not os.path.isdir(dirname):
      _raise('failure to lock because of missing parent dir of ',
             self.lock_path)
        
    at = now()
    while True:
      try:
        os.mkdir(self.lock_path)
        break
      except OSError as e:
        if e.errno == errno.EEXIST:
          if ((not self.remove_stale_lock())
              and (now() > (at + self.timeout))):
            raise TimedDirLock.LockError(
                'Timeout when trying to acquire lock \'',
                self.lock_path, "' from process ", self.locked_by_pid())
          time.sleep(self.sleep_time_in_seconds)
          continue
        else:
          raise
    # I got the lock!
    self.acquired = now()
    self.lock_count = 1
    write_file(self.id_file, self.own_id())

  def own_id(self):
    return ':'.join((str(os.getpid()), str(self.id)))

  def locked_by_id(self):
    return read_file(self.id_file)

  def locked_by_pid(self):
    x = self.locked_by_id()
    if ':' in x:
      return int(x.split(':')[0])
    return int(x)

  def verify_lock(self, strict=False, refresh=True):
    if not self.acquired:
      if strict:
        raise TimedDirLock.LockError(
                "Unlock: am not locked to '", self.lock_path, "'")
      return False
    check = self.locked_by_id()
    if (not check) or (check != self.own_id()):
      self.acquired = None
      self.lock_count = 0
      self.warn("lost lock '", self.lock_path, "'")
      return False
    if refresh:
      os.utime(self.lock_path, None)
    return True

  def __exit__(self, *ignored_args):
    if self.verify_lock(strict=True):
      if self.lock_count > 1:
        self.lock_count -= 1
        return
      self.acquired = None
      self.lock_count = 0
      shutil.rmtree(self.lock_path)

  def __del__(self):
    self.__exit__()


class Tim(Notify):
  seconds_per_minute = 60.0
  stale_threshold = 5 * seconds_per_minute

  def __init__(self, notify_func, base_dir=None):
    Notify.__init__(self, notify_func)

    if not base_dir:
      base_dir = j(os.environ['HOME'], '.tim')
    base_dir = os.path.abspath(base_dir)
    self.set_base_dir(base_dir)

    self.timelog = Timelog(notify_func, self.timelog_dir)
    self.lock = TimedDirLock(notify_func, self.lock_path)
    #self.lock.remove_stale_lock()

  def set_base_dir(self, base_dir):
    self.base_dir = base_dir
    if not os.path.isdir(self.base_dir):
      #try:
        os.makedirs(self.base_dir)
      #except OSError as e:
      #  if e.errno != errno.EEXIST:
      #   raise
    self.state_file_path = j(base_dir, 'running')
    self.timelog_dir = j(base_dir, 'timelog')
    self.lock_path = j(base_dir, 'lock')
    self.forgotten_path = j(base_dir, 'forgotten')

  def new(self, name):
    with self.lock:
      self.timelog.add_name(name)
    self.msg('added ', name)

  def stop(self, comment=None):
    stopped_state = None
    with self.lock:
      stopped_state = self.get_state()
      t = stopped_state.timing
      if t.started:
        if comment:
          if t.comment:
            t.comment = ' '.join((t.comment, comment))
          else:
            t.comment = comment
        self.timelog.add_timing(t, directly_to_file=True)
        # clear the state on disk
        empty_state = self.get_state(read=False)
        empty_state.save()
      else:
        stopped_state = None # nothing was stopped
    if stopped_state:
      self.notify(Notify.STOPPED, stopped_state)
    return stopped_state

  def handle_stale_state(self, state):
    """see if the daemon was interrupted (e.g. box suspended).
    If so, don't count the time that the daemon was suspended, or
    stop everything, depending on how much time has passed."""
    stale_reason = state.is_stale()
    if stale_reason:
      self.notify(Notify.STALE, (state, stale_reason))
      if not gently_kill_process(state.pid):
        self.warn('Unable to kill timer process (', pid, ')')
      # assume the user forgot about me, and exit.
      self.stop()
      # Reload.
      state.read()

  def get_state(self, read=True):
    'return the current state as on disk, no automatic fixing of stale status.'
    return State(self.state_file_path, read)

  def get_status(self):
    'fixes any stale timers, then returns the state.'
    with self.lock:
      state = self.get_state()
      if state.timing.started:
        self.handle_stale_state(state)
      return state

  def start(self, name_to_start, comment=None):
    '''name_to_start: full project name ('root.bar.baz') '''

    with self.lock:
      state = self.get_state()

      t = state.timing
      if t.started:
        if t.name == name_to_start:
          self.notify(Notify.ALREADY_RUNNING, name_to_start)
          if t.add_comment(comment):
            state.save()
          return True
      self.stop()
      state.write_starting()

    self.notify(Notify.STARTED, name_to_start)
    sys.stdout.flush()
    sys.stderr.flush()

    daemon_out = open(j(self.base_dir, 'daemon.log'), 'a+')
    daemon_out.write(msgs2str(time2str(now()),' -- launching daemon\n'))
    daemon_out.flush()

    with daemon.DaemonContext(
             stdout=daemon_out, stderr=daemon_out,
           ):
      try:
        my_pid = os.getpid()

        original_starting_time = str2time( time2str( now() ) )
        daemon_out.write(msgs2str(time2str(original_starting_time),
                         ' -- daemon started: ', my_pid, '\n'))
        daemon_out.flush()

        state = self.get_state(read=False)
        state.set_values(
          name=name_to_start,
          started=original_starting_time,
          minutes=1,  # <-- debug  minutes=0,
          comment=comment,
          pid=my_pid)
        with self.lock:
          state.save()

        while True:
          # try to run just after the break of the minute
          time.sleep(Tim.seconds_per_minute + 1
                     - (now() % Tim.seconds_per_minute))

          with self.lock:
            # verify that the state still shows the same starting time that
            # I was called to act on.
            state.read()
            t = state.timing
            if t.started:
              self.handle_stale_state(state)
            if not (state.pid == my_pid
                    and t.name == name_to_start):
              # the current state no longer concerns me.
              return

            # all is well, update the state
            t.minutes = ((int(now()) - t.started) 
                         / Tim.seconds_per_minute)
            state.save()
      finally:
        _msg('daemon done')


  def adjust_start(self, new_start):
    with self.lock:
      state = self.get_state()
      t = state.timing
      if not t.started:
        _raise('Can only adjust when a timing is running.')
      tnow = now()
      if new_start > tnow:
        _raise('Can only set a starting time that is in the past.')
      t.started = new_start
      t.minutes = int((tnow - new_start) / 60)
      state.save()

  def adjust_add(self, minutes):
    with self.lock:
      state = self.get_state()
      t = state.timing
      if not t.started:
        _raise('Can only adjust when a timing is running.')
      t.started -= minutes * 60
      tnow = now()
      t.started = min(t.started, tnow)
      t.minutes = int((tnow - t.started) / 60)
      state.save()

  def adjust_set(self, minutes):
    assert(minutes >= 0)
    with self.lock:
      state = self.get_state()
      t = state.timing
      if not t.started:
        _raise('Can only adjust when a timing is running.')
      t.started = now() - (minutes * 60)
      t.minutes = minutes
      state.save()

  def _forge(self, name, started, minutes, comment=None):
    t = Timing(name=name, started=started, minutes=minutes,
               comment=comment)
    with self.lock:
      self.timelog.add_timing(t)
    return t

  def forge(self, name, started, minutes, comment=None):
    t = self._forge(name, started, minutes, comment)
    self.notify(Notify.MSG, msgs2str('forged ', repr(t)))
    yearnr = time2year(t.started)
    self.notify(Notify.FIX_NEEDED, yearnr)

  def tickoff(self, name, minutes, comment=None):
    if minutes < 0:
      _raise('no negative tickoff allowed.')
    t = self._forge(name, now(), -minutes, comment)
    self.notify(Notify.MSG, msgs2str('ticked off: ', repr(t)))

  def find_full_name(self, name):
    return self.timelog.get_totals().find_full_name(name)

  def undo_last_tickoff(self):
    with self.lock:
      t = self.timelog.find_last_tickoff()
      if not t:
        return None
      self.timelog.remove_timing(t)
    y = time2year(t.started)
    if y != time2year(now()):
      self.notify(Notify.FIX_NEEDED, y)
    return t

  def rename(self, from_name, to_name):
    self.timelog.rename(from_name, to_name)

  def forget(self, *names):
    totals = self.timelog.get_totals()
    full_names = []
    for name in names:
      full_name = totals.find_full_name(name)
      if full_name != name:
        _raise("'", name, '\' is not a full name. Try:\n  tim forget "',
               full_name, '"')
      full_names.append(totals.find_full_name(name))

    for name in full_names:
      forgotten_name = '%s__%s' % (name, filename_timestamp())
      forgotten_path = j(self.forgotten_path, forgotten_name)
      write_file(forgotten_path, '...\n')
      if self.timelog.forget(name, forgotten_path):
        self.msg("forgot about '", name, "'")
      else:
        self.warn("found nothing to forget about '", name, "'")

  def get_all_forgotten_ids(self):
    if not os.path.exists(self.forgotten_path):
      return []
    return [f for f in os.listdir(self.forgotten_path)
              if ('__' in f) and not f.startswith('.')]

  def recall(self, forgotten_id, as_name=None, do_add=False):
    if os.sep in forgotten_id:
      forgotten_path = os.path.abspath(forgotten_id)
    else:
      forgotten_path = j(self.forgotten_path, forgotten_id)
    return self.timelog.recall(forgotten_path, as_name, do_add)

# invocation via commandline #################################################

help_hint = "\n--> 'tim help' may help."

class TimCmdline:
  def __init__(self, args):
    # read and strip --base option
    i = 0
    gl_args = {}
    while i < len(args):
      arg = args[i]
      matched = False
      for gl_arg in ('--base', '--timewarp'):
        if arg.startswith(gl_arg):
          if gl_args.get(gl_arg) is not None:
            _raise('Only one ', gl_arg, ' option allowed')
          rest = arg[len(gl_arg):]
          if rest:
            if rest[0] != '=':
              _raise("Invalid argument: '", arg, "'")
            gl_args[gl_arg] = rest[1:]
            del args[i]
            matched = True
            break
          else:
            if i+1 >= len(args):
              _raise('--base needs an argument.')
            gl_args[gl_arg] = args[i+1]
            del args[i+1]
            del args[i]
            matched = True
            break
      if not matched:
        i += 1

    timewarp = gl_args.get('--timewarp')
    if timewarp:
      global global_timewarp
      global_timewarp = int(timewarp)

    self.args = args
    self.tim = Tim(self.notify, base_dir=gl_args.get('--base'))

    if not args:
      # when called without arguments show status
      function = self.cmd_status
    else:
      cmd = args[0]
      func_name = 'cmd_' + cmd

      function = None
      if hasattr(self, func_name):
        function = getattr(self, func_name)
      if not callable(function):
        # convenience: omit 'adjust' for +-@= time adjustments
        if args[0][0] in '@+-=':
          return self.cmd_adjust(*args)
        if len(args) == 1:
          # convenience: omit 'start' for known project names
          return self.cmd_start(*args)
        _raise("Unknown command: '", cmd, "'", help_hint)

    return function(*(args[1:]))

  def usage(self, error_message=None):
    _msg(__doc__)
    if (error_message):
      _errmsg(error_message)
      exit(1)
    exit(0)

  def cmd_new(self, *args):
    if len(args) < 1:
      _raise("'new' needs an argument: an unknown name to create.")
    for arg in args:
      self.tim.new(arg)

  def notify(self, key, arg):
    if key == Notify.ALREADY_RUNNING:
      name = str(arg)
      _warn('Already running: ', name)
    elif key == Notify.STOPPED:
      state = arg
      t = state.timing
      _msg('stopped ', t.name,
           ' (', mins2str(t.minutes), ')')
    elif key == Notify.STARTED:
      name = str(arg)
      _msg('started ', name)
    elif key == Notify.FIX_NEEDED:
      yearnr = arg
      _warn('remember to call \'tim fix ', yearnr, '\' at some point.')
    elif key == Notify.MSG:
      msg = arg
      _msg(msg)
    elif key == Notify.WARN:
      msg = arg
      _warn(msg)
    elif key == Notify.ERROR:
      msg = arg
      _raise(msg)
    elif key == Notify.STALE:
      state, reason = arg
      t = state.timing
      if reason == State.REASON_STALE:
        reason = 'was not updated for a long time'
      elif reason == State.REASON_DAEMON_EXITED:
        reason = 'the daemon is no longer running'
      _warn('detected undead timer!',
            '\nStopped timer, not counting interrupted time.',
            '\n         name: ', t.name,
            '\n      started: ', time2str(t.started),
            '\n      ran for: ', mins2str(t.minutes),
            '\n  interrupted: ', mins2str((now()-t.started)/60 - t.minutes),
              ' hours ago',
            '\n       reason: ', reason,
            )

  def cmd_start(self, *args):
    if len(args) < 1:
      _raise("'start' takes a name argument.\n", name_syntax_docstr)
    name = self.tim.find_full_name(args[0])
    comment = ' '.join(args[1:])
    if not name:
      _raise("Unknown name: '", args[0], "' -- ",
             "try 'tim new ", args[0], "' first?", help_hint)
    self.tim.start(name, comment)

  def cmd_stop(self, *args):
    comment = ' '.join(args)
    stopped_state = self.tim.stop(comment)
    # notification
    if not stopped_state:
      _raise('No timer is running.')

  def cmd_status(self, *args):
    if args:
      _raise("'status' takes no arguments")
    status = self.tim.get_status()
    t = status.timing
    if t.started:
      _msg('Running: ', t.name, '=', mins2str(t.minutes), ' (since ',
           time2str(t.started), ')')
    else:
      _msg('Not running.')

  def cmd_totals(self, *args):
    i = 0
    only = None
    round_to_minutes = None
    show_surplus = False
    flat = False
    while i < len(args):
      arg = args[i]
      if 'only'.startswith(arg):
        i += 1
        if not (i < len(args)):
          _raise("expecting a list of names after 'only'")
        only = args[i].split(',')
      elif 'round'.startswith(arg):
        i += 1
        if not (i < len(args)):
          _raise("expecting a rounding duration after 'round'")
        round_to_minutes = str2mins(args[i])
      elif '-s' == arg:
        show_surplus = True
      elif '-f' == arg:
        flat = True
      else:
        _raise("unknown argument for 'totals': '", args[0], "'")
      i += 1

    totals = self.tim.timelog.get_totals()
    if totals.is_empty():
      _msg('Nothing is recorded.')
      return

    if only:
      names = set()
      for name in only:
        names.update( totals.find_full_names(name) )
      only = names

      if not only:
        _msg('Nothing is recorded for the given selection.')
        return

    if only:
      m = 'Totals, selection:\n'
    else:
      m = 'Totals:\n'

    rounder = None
    if round_to_minutes:
      rounder = MinutesRounder(round_to_minutes)
    _msg(m, totals.to_string(flat=flat,
                             only=only,
                             rounder=rounder))
    if show_surplus and rounder and rounder.enabled:
      _msg(m, rounder.surplus.to_string(flat=flat, omit_zero=True))


  def cmd_log(self, *args):
    query_result = self.tim.timelog.run_query_phrase(args)
    _msg(query_result.description_str())
    if not query_result.timings:
      _warn('No entries found.')
      return
    for entry in query_result.timings:
      _msg(entry.to_string(rounder=query_result.rounder))
    _msg(query_result.totals_string())

  def cmd_fix(self, *args):
    clear_initial_totals = False
    start_year = None
    fix_overlaps = None

    for arg in args:
      if arg == '--clear':
        clear_initial_totals = True
      elif arg.startswith('--overlaps='):
        overlap_str = arg[11:]
        if 'shift' == overlap_str:
          fix_overlaps = Timelog.FIX_OVERLAPS_SHIFT
        elif 'drop' == overlap_str:
          fix_overlaps = Timelog.FIX_OVERLAPS_DROP
        elif 'ignore' == overlap_str:
          fix_overlaps = Timelog.FIX_OVERLAPS_IGNORE
        else:
          _raise("Unknown --overlaps arg: '", overlap_str, "'")
          
      elif arg.isdigit():
        if start_year:
          _raise('Multiple start years make no sense.')
        start_year = int(arg)
      else:
        _raise("Invalid argument: '", arg , "'", help_hint)

    self.tim.timelog.fix(start_year, clear_initial_totals, fix_overlaps)

  def cmd_adjust(self, *args):
    if len(args) < 1:
      _raise("'adjust' needs an adjustment argument", help_hint)
    if (len(args) == 2) and (args[0] in ('@', '=', '+', '-')):
      args = (''.join(args),)
    if len(args) != 1:
      _raise("'adjust' takes exactly one argument", help_hint)
    arg = args[0]
    if arg[0] not in '@+-=':
      _raise("invalid 'adjust' argument: '", arg, "'", help_hint)

    cmd = arg[0]
    try:
      minutes_arg = str2mins(arg[1:])
    except FormatError as e:
      _raise("invalid 'adjust' argument: ", e.msg, help_hint)

    if cmd == '@':
      # set starting time
      # get current time less start today (set hours and minutes to zero)
      time_now = now()
      day_start = str2time( time2str(time_now)[:10] + ' 00:00' )
      minutes_today = (time_now - day_start) / 60
      if minutes_arg > minutes_today:
        # the user must have meant yesterday.
        minutes_arg -= 24*60
      new_start = day_start + (minutes_arg * 60)
      self.tim.adjust_start(new_start)
    elif cmd == '+':
      self.tim.adjust_add(minutes_arg)
    elif cmd == '-':
      self.tim.adjust_add(-minutes_arg)
    elif cmd == '=':
      self.tim.adjust_set(minutes_arg)
    else:
      _raise("invalid 'adjust' argument: '", arg, "'", help_hint)
    self.cmd_status()

  def cmd_forge(self, *args):
    if len(args) != 4:
      _raise("'forge' needs a start date, time-of-day, a name and a duration.",
             '\n  forge 2012-12-31 23:59 champagne 6:31')

    d, t, name, duration = args
    date = '%s %s' % (d, t)
    self.tim.forge(name, str2time(date), str2mins(duration))

  def cmd_tickoff(self, *args):
    if '--undo' in args:
      if len(args) != 1:
        _raise('--undo cannot be combined with other arguments.')
      t = self.tim.undo_last_tickoff()
      if t:
        _msg('Tickoff undone: ', repr(t))
      else:
        _warn('No tickoff found.')
      return

    name = None
    minutes = None

    for arg in args:
      if minutes is None:
        minutes = str2mins(arg, raise_on_err=False)
        if minutes is not None:
          continue
      if name is None:
        name = self.tim.find_full_name(arg)
        if name is not None:
          continue
      _raise("unknown argument: '", arg, "'")

    if not name:
      _raise('I need a name argument.')

    if not minutes: # catch both None and zero
      _raise('I need a time argument.')

    self.tim.tickoff(name, minutes, comment='tickoff')

  def cmd_rename(self, *args):
    if len(args) < 2:
      _raise("'rename' needs two args, an existing and a non-existing name.")
    from_name = args[0]
    to_name = args[1]

    self.tim.rename(from_name, to_name)
    _msg("Renamed '", from_name, "' to '", to_name, "'")

  def cmd_forget(self, *args):
    if len(args) < 1:
      _raise("'forget' needs at least one name argument.")
    forgotten = self.tim.forget(*args)
    if forgotten:
      _msg('Forgot about ', ', '.join(forgotten))

  def cmd_recall(self, *args):
    if not args:
      ids = self.tim.get_all_forgotten_ids()
      if not ids:
        _msg('My memory is impeccable. No ids to recall.')
      else:
        _msg('I dimly remember:\n', '\n'.join(sorted(ids)))
      return

    forgotten_id = args[0]
    as_name = None
    do_add = False
    i = 1
    while i < len(args):
      arg = args[i]
      if arg in ('as'):
        i += 1
        if i >= len(args):
          _raise("expecting name after 'as' keyword")
        arg = args[i]
        if as_name is not None:
          _raise("can't use name '", arg, "', already have name '", 
                 as_name, "'")
        as_name = arg
      elif 'add' == arg:
        if do_add:
          _raise("I know, add. One 'add' is enough.")
        do_add = True
      else:
        _raise("unknown argument: '", arg, "'", help_hint)

      i += 1
    if self.tim.recall(forgotten_id, as_name, do_add):
      _msg("restored timings from '", forgotten_id, "'")
    else:
      _warn('nothing was restored.')

  def cmd_help(self, *args):
    if not args:
      lines = []
      for line in __doc__.split('\n'):
        if line.startswith('--- ') and line.endswith(' ---'):
          break
        lines.append(line)
      _msg('\n'.join(lines))
      _msg('--- tim help ---')
      self.cmd_help('help')
      return

    if 'all' in args:
      _msg(__doc__)
      return

    for arg in args:
      lines = []
      found = False
      match = '--- tim ' + arg + ' ---'
      usage_part = False
      usage = []
      found_usage = False
      usage_matches = ('  tim ' + arg + ' ', '  tim [' + arg + ']')

      if arg in ('example', 'examples'):
        match = '--- EXAMPLE ---'
        usage_matches = ()

      for line in __doc__.split('\n'):
        if line.startswith('--- ') and line.endswith(' ---'):
          found = False
          found_usage = False
          usage_part = False
        
          if line == match:
            found = True
            continue
        else:
          if line == 'Command line usage:':
            usage_part = True
            continue

          if usage_part:
            if (not line.strip()) or line.startswith('  tim '):
              found_usage = False
            if not found_usage:
              if any([line.startswith(u) for u in usage_matches]):
                found_usage = True
            if found_usage:
              usage.append(line)
            
        if found:
          lines.append(line)

      if not lines:
        _warn("Don't know anything about '", arg, "'", help_hint)
      else:
        if len(args) > 1:
          _msg('--- tim ' + arg + ' ---')
        if usage:
          _msg('usage:\n', '\n'.join(usage), '\n')
        _msg('\n'.join(lines))


if __name__ == "__main__":
  # run commandline client.

  try:
    TimCmdline(sys.argv[1:])
  except Error, e:
    handle_error(e)


