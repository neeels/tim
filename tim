#!/usr/bin/env python
# coding: utf8
#
# Tim
# ===
# 
# project timer (GUI + cmdline)
# 
# You enter project names and start and stop them.
# Tim will keep track of how much you worked (and when) and how many of these
# worked hours you have already submitted to your money supplier.
# 
# (c) Copyright 2013 by Neels Janosch Hofmeyr <neels@hofmeyr.de> (GPLv3)
# 
# This file is part of Tim project timer.
# 
# Tim project timer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tim project timer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tim project timer.  If not, see <http://www.gnu.org/licenses/>.

__doc__ = '''Tim project timer.

You enter names and start and stop them. Tim tracks how much you worked on
which (and when) and, if you like, how many of these worked hours you have
already submitted to your money supplier.

usage:
  tim systray
  tim new <project-name>
  tim [start] <project-name> [<comment>]
  tim [running]
  tim [adjust] [@<started-time>|+<duration>|-<duration>|=<duration>]
  tim stop [<comment>]
  tim totals [-l <name>]
  tim log [-l <name>] [-s <date>] [-d|-w|-m|-y] [-D|-W|-M|-Y] [-n <nr>]
  tim tickoff <hours> [<project-name>] 
  tim tickoff --undo
  tim rename <current-project-name> <new-project-name>
  tim forget <project-name>
  tim remember [<id>] [--as <project-name>] [--add-to <project-name>]


--- tim systray ---
Launch a systray icon. Put this in your window manager's autostart.

--- tim new ---
Announce a new project name. You can use dots '.' to create subgroups of
projects.
  tim new foo
  tim new yoyodyne.abc

--- tim start ---
When you start working on a given project, call 'tim start myprojectname'.
The word 'start' can be omitted. Before you can start a project, you must tell
Tim about with the 'tim new' command.

Project names names can be grouped, simply by inserting dots in the name. Any
number of grouping levels is allowed.

As soon as the project name is known ('tim start mygroup.myname'), you only
need to type the part after the last dot ('tim myname'), as long as it does
not have the same name as any other project in any other group.

--- tim running ---
Show the current timer, if any is running. This is the same as calling 'tim'
without any arguments.

--- tim adjust ---
When a timer is currently running, adjust the recorded time. This always
shifts the started-time so that the desired duration results when counting up
to the current moment in time. The word 'adjust' may be omitted.
  @<started-time>
    I have actually started working on this project at <started-time>.
    Adjust the timing counter for the current project accordingly.
    <started-time> format is 'HH:MM', e.g. '14:59'. Wraps past midnight
    (yesterday's time is used when today's time would be in the future).
      tim @9      # make as if I called 'start' at 9 o'clock this morning
      tim @15:30  # ... at half past three. 
  +<duration>
    Add <duration> to the currently running timer.
    <duration>: [HH][:MM], for example:
      tim +1      # add one hour
      tim +1:30   # add one and a half hours
      tim +1.5    # add one and a half hours (decimal dot)
      tim +:30    # add thirty minutes
  -<duration>
    Subtract <duration>. '- 10' is the same as '-10' and '+ -10'.
  =<duration>
    Set the current counter to exactly <duration> hours.
      tim =1      # make as if I called 'start' one hour ago

--- tim stop ---
Stop the currently running timer. Any arguments after the word 'stop' are
stored as a comment for the hours just worked.

--- tim totals ---
Print the current timing totals of hours spent vs. hours ticked-off on a
per-group and per-project basis.
  -l <name>
    Limit the listing to this project (or group).

--- tim log ---
Show the timings for this week (-W is the default). Options:
  -l <name>
    Limit the listing to this project (or group).
  Time options:
    default: show each timing in hours and minutes
    -d/-w/-m/-y  combine hours for each day/week/month/year
    -D/-W/-M/-Y  start at the beginning of this day/week/month/year
    -f  start one full time period ago, flowing, floating past boundaries.
        For example, '-f -W' starts seven days ago, instead of last monday;
        '-f -M' starts the same day last month, instead of this month's 1st.
    -n <nr>
       Repeat above time period for <nr> times into the past.
  -s <date>
    Start at <date>, of format 'YYYY-MM-DD_hh:mm', where everything left and
    right of 'hh' may be omitted.
      -s 2013-01-11
        Start at 00:00 on 11th of January, 2013.
      -s 2013-01-11_23:45
        Start at 23:45 on 11th of January, 2013.
      -s 10
        Same as '-s 10:00', start 10 o'clock today
      -s 1_
        Same as '-s 1_0:00', start on the first day of this month
      -s 1-1_
        Same as '-s 1-1_0:00', start on the most recent 1st of January
      -s 3-32_
        Same as '-s 4-1_0:00', start on the most recent 1st of April (wrap!)
      (etc.)

--- tim tickoff ---
Record hours that you have already billed your money supplier for. If you are
timing private / hobby projects, your total hours will simply grow. But if you
have an employer, ticking off is useful to keep track of how many hours you
have actually passed on to your employer's accounting. If you are using
tickoff for any given project, you probably want to reach a total of zero for
that project at regular intervals. If you've worked less than you billed, your
total hours become negative.
- If no project name is supplied, the tickoff is chronologically spread across
  all projects, so that the hours worked longest ago are ticked off first.
    tim tickoff 32
- You can tickoff a group (yoyodyne), in which case the hours contained in any
  sub-projects and sub-sub-projects are ticked-off in their chronological
  order (see examples below). You can also tickoff subprojects specifically.
    tim tickoff 32 yoyodyne
- If a group's total is negative, I've already billed hours I haven't worked
  yet; over time, sub-projects of such a group will receive new hours, but the
  negative total of the parent will only be neutralised at the next tickoff
  command. You may call 'tim tickoff 0 mygroupname' to chronologically
  neutralise a negative total with hours worked in sub-projects.
    tim tickoff 0 yoyodyne  # neutralise negative total with sub-projects
- If you want to keep strictly separate project groups, you should take
  care to never omit the group name when calling the tickoff command. If it
  should go wrong one day, you can undo tickoffs one by one with:
    tim tickoff --undo

--- tim rename ---
Rename a project while keeping its hours and logs. This may also move projects
around between groups.
Note that this changes the name in all logs back to the start of time, so the
'tim log' command will not look the same as before.

--- tim forget ---
Remove a given project from accounting. The data will still be sitting in the
database, but it will appear to be completely removed with all its history
when interacting with tim.

--- tim remember ---
Recover a project previously forgotten with 'tim forget'. Run without
arguments to get a listing of IDs for forgotten projects or groups.

--- EXAMPLE ---
  This example shows a sequence of tim commands. Imagine that time passes
  between each pair of start ... stop commands.
  
  tim new foo
  tim foo
  tim stop
  tim foo
  tim stop

  tim new yoyodyne.abc     # announce project abc in group yoyodyne
  tim yoyodyne.abc         # start timing for project abc in the group yoyodyne
  tim +1                   # fake starting-time so that I've worked 1 hour now
  tim stop "fix a bug"     # stop timing, record in the log with a message
  tim abc                  # start yoyodyne.abc; tim finds 'abc' in 'yoyodyne'.
  tim stop
  tim new yoyodyne.xyz.bar # announce project bar in new group yoyodyne.xyz
  tim xyz                  # start yoyodyne.xyz (yes, "groups" can also start)
  tim abc                  # stop yoyodyne.xyz, start yoyodyne.abc, in one go
  tim stop

  tim log                  # show the log of this week (starting monday)
  tim log -w -n 5          # show last five weeks (five times seven days)
  tim log yoyodyne         # show log for yoyodyne.* projects only

  tim totals               # show the sum of all hours for all projects
  tim tickoff 32 yoyodyne  # I have billed yoyodyne for 32 hours.
  tim totals               # Above 32 hours are now subtracted from the totals.
 '''

import re, os, errno, time, shutil, sys, signal
import daemon
import lockfile
from os.path import join as j
from time import time as now


# messaging and error handling ###############################################

def msgs2str(msgs):
  return ''.join([str(m) for m in msgs])

class Error(Exception):
  def __init__(self, *msgs):
    self.msg = msgs2str(msgs)
  def __str__(self):
    return self.__class__.__name__ + ': ' + self.msg

def _raise(*msgs):
  raise Error(*msgs)

def _warn(*msgs):
  print '***', msgs2str(msgs)

def _msg(*msgs):
  print msgs2str(msgs)

def _errmsg(*msgs):
  sys.stderr.write('tim: ')
  for msg in msgs:
    sys.stderr.write(msg)
  sys.stderr.write('\n')
  sys.stderr.flush()
  

# generic conversion functions ###############################################

def mins2str(float_mins):
  sign = 1
  frac = 59.0
  if float_mins < 0:
    float_mins = -float_mins
    sign = -1
    frac = 1.0
  
  minutes = int(float_mins)
  if float_mins - float(minutes) > (frac/60):
    minutes += 1

  h, m = divmod(minutes, 60)

  if m == 0:
    return str(sign * h)
  elif sign < 0:
    # just 'h *= sign' won't work if h == 0.
    return "-%d:%02d" % (h,m)
  else:
    return "%d:%02d" % (h,m)

def str2mins(str_hours):
  try: 
    if str_hours.find(':') < 0:
      return int(round(float(str_hours) * 60.0))

    h, m = str_hours.split(':')
    sign = 1
    if h.startswith('+'):
      h = h[1:]
    if h.startswith('-'):
      h = h[1:]
      sign = -1

    if not h or len(h) < 1:
      fh = 0
    else:
      fh = float(h)

    if not m or len(m) < 1:
      fm = 0
    else:
      fm = float(m)

    return int(sign * round(fh * 60.0 + fm))
  except Exception, e:
    _raise("Time format error, not a time string: ", str_hours or "None")

TIMESTR_FORMAT = "%Y-%m-%d %H:%M"

def time2str(float_time):
  if not float_time:
    return None
  return time.strftime(TIMESTR_FORMAT, time.localtime(float(float_time)))

def str2time(str):
  if not str or len(str) < 1:
    return None
  return time.mktime( time.strptime(str, TIMESTR_FORMAT) )

def time2year(float_time):
  return int(time.strftime('%Y', time.localtime(float_time)))


# os file & process functions ################################################

def write_file(path, contents, mkdirs=True):
  if mkdirs:
    dirname = os.path.dirname(path)
    if not os.path.exists(dirname):
      os.makedirs(dirname)
  f = open(path, "w")
  f.write(contents)
  f.close()

def append_to_file(path, *contents):
  f = open(path, "a")
  for c in contents:
    f.write(c)
  f.close()

def read_file(path):
  try:
    f = open(path, "r")
    contents = f.read()
    f.close()
    return contents
  except IOError:
    return None

def read_file_lines(path):
  try:
    f = open(path, "r")
    contents = f.readlines()
    f.close()
    return contents
  except IOError:
    return None

def process_is_running(pid):
  try:
    os.kill(int(pid), 0)
    return True
  except OSError as e:
    if e.errno == errno.ESRCH: # no such process
      return False
    raise

def gently_kill_process(pid):
  if not (pid and process_is_running(pid)):
    return True
  msg('kill -SIGINT ', pid)
  os.kill(pid, signal.SIGINT)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  msg('kill -SIGTERM ', pid)
  os.kill(pid, signal.SIGTERM)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  msg('kill -SIGKILL ', pid)
  os.kill(pid, signal.SIGKILL)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  return False
 

# strings and regexes ########################################################

INIT_STR = 'init:'
NAME_RE = '([a-zA-Z_][a-zA-Z0-9_]*\.)*[a-zA-Z_][a-zA-Z0-9_]*'
TIME_RE = '[+-]{0,1}[0-9:]+'
DATE_RE = r'(\d{1,4})-(\d{1,2})-(\d{1,2})[_ ](\d{1,2})[-:](\d{1,2})'
NAME_STR_RE = '\A' + NAME_RE + '\Z'
LOG_INITIAL_TOTAL_RE = '^' + INIT_STR + ' *([^ *])=(' + TIME_RE + ')$'
TIMING_RE = '^' + DATE_RE + '[: ]+([^ ]+) (' + TIME_RE + ')($| (.*)$)'
STATE_RE = '^([0-9]+) (.*)$' # a PID, and a log entry (parsed in second step)
TOTALS_LINE_RE = '^(' + NAME_RE + ')=(' + TIME_RE + ')$'

class Regex:
  '''Caches compiled regular expressions. A call to
  Regex.match('([a-z]*) ([0-9]*)', 'foo 123') returns a re.match object and
  compiles that regex only once, no matter how often match() is called.'''
  cache = {}
  @staticmethod
  def compiled(regex):
    compiled = Regex.cache.get(regex)
    if not compiled:
      compiled = re.compile(regex)
      Regex.cache[regex] = compiled
    return compiled
  @staticmethod
  def match(regex, string):
    return Regex.compiled(regex).match(string)
    

# classes implementing Tim ###################################################

class Notify(object):
  def __init__(self, notify_func):
    ''' notify_func(key, arg): function that notifies the user; the
    calling code can/should show these messages to the user in some way.

    key: One of the Notify.CONSTANTs
    
    arg: depends on the key...

      Notify.STARTED,
      Notify.ALREADY_RUNNING:
        arg: the name of the project that was successfully started / stopped
              / was not started since the same name is already running.

      Notify.STOPPED,
      Notify.STALE:
        arg: a State instance reflecting the state that has just
             been stopped and recorded in the time log. A stale state
             (NOTIFY_STALE) is a running state that has not been updated for a
             long time, maybe because the machine was suspended or crashed.
             The timing was saved to the time log, only counting the time that
             the state was not stale (state.timing.minutes).

      Notify.MSG,
      Notify.WARN,
      Notify.ERROR:
        arg: a message to display.
    '''
    self.notify_func = notify_func

  def msg(self, *msgs):
    self.notify_func(Notify.MSG, msgs2str(msgs))

  def warn(self, *msgs):
    self.notify_func(Notify.WARN, msgs2str(msgs))

  def err(self, *msgs):
    self.notify_func(Notify.ERROR, msgs2str(msgs))

  ALREADY_RUNNING = 0
  STARTED = 1
  STOPPED = 2
  STALE = 3
  MSG = 4
  WARN = 5
  ERROR = 6



class Timing:
  def __init__(self, **kwargs):
    self.set_values(**kwargs)
  
  def set_values(self, started=None, name=None, minutes=None, comment=None):
    self.started = started
    self.name = name
    self.minutes = minutes
    self.comment = comment
    if not self.comment:
      self.comment = None
    return self

  def clear(self):
    self.set_values()

  def started_str(self):
    return time2str(self.started)

  def serialize(self):
    return self.__str__() + '\n'

  def __str__(self):
    if self.started:
      started_str = self.started_str()
    else:
      started_str = 'not_started'
    elts = [started_str,
            self.name or 'unnamed',
            mins2str(self.minutes or 0)]
    if self.comment:
      elts.append(self.comment)
    return ' '.join(elts)

  def deserialize(self, line):
    match = Regex.match(TIMING_RE, line)
    if not match:
      return None
    else:
      self.set_values(
                    started=str2time('%s-%s-%s %s:%s' % match.groups()[0:5]),
                    name=match.group(6),
                    minutes=str2mins(match.group(7)),
                    comment=match.group(8),
                   )
      return self



class State:
  STOPPED = 'stopped'

  def __init__(self, read=True, state_file_path=None):
    self.timing = Timing()
    self.pid = None
    self.state_file_path = state_file_path or Tim.state_file_path
    if self.state_file_path and read:
      self.read()

  def __str__(self):
    if self.timing.started:
      return str(self.pid) + ' ' + self.timing.serialize()
    else:
      return State.STOPPED

  def set_values(self, pid=None, **kwargs):
    self.pid = pid
    return self.timing.set_values(**kwargs)

  def serialize(self):
    return str(self) + '\n'

  def deserialize(self, string):
    match = Regex.match(STATE_RE, string)
    if not match:
      return False
    # State only adds the pid field to Timing, so
    # STATE_RE only adds a pid nr to TIMING_RE
    self.pid = int(match.group(1))
    self.timing.deserialize(match.group(2))
    return True

  def save(self):
    "write this state to file"
    write_file(self.state_file_path, self.serialize())
    return self

  def clear(self):
    self.pid = None
    self.timing.clear()

  def read(self):
    self.clear()

    if not os.path.isfile(self.state_file_path):
      return False

    statestr = read_file(self.state_file_path)
    if statestr is None:
      return True # stopped. no data.
    statestr = statestr.strip()
    if statestr == State.STOPPED:
      return True # stopped. no data.

    return self.deserialize(statestr)

  def is_stale(self):
    assert(self.timing.started)
    expected_now = (self.timing.started 
                    + (self.timing.minutes * Tim.seconds_per_minute))
    timestep = now() - expected_now
    return ((timestep > Tim.stale_threshold)
            or not process_is_running(self.pid))


class Timelog(Notify):

  def __init__(self, notify_func, timelog_base_path):
    Notify.__init__(self, notify_func)
    self.timelog_base_path = timelog_base_path
    self.totals_path = j(self.timelog_base_path, 'totals')
    self.clear()

  def clear(self):
    self.timelog_files = {}
    self.totals = None

  class InvalidNameError(Error):
    pass

  def validate_project_name(self, name):
    if not Regex.match(NAME_STR_RE, name):
      raise Timelog.InvalidNameError("Invalid name for a project: '", name,
               "'\n(only letters, numbers and '_' allowed in project names,",
               " separated by '.',\nnumbers may not appear at the start.)")

  def get_totals(self):
    if self.totals is None:
      lines = read_file_lines(self.totals_path)
      totals = {}
      if lines:
        for line in lines:
          try:
            match = Regex.match(TOTALS_LINE_RE, line)
            if not match:
              self.warn("DROPPING invalid line in '", self.totals_path, "':\n", line, '\n')
              continue
            name = match.group(1)
            self.validate_project_name(name)
            minutes = str2mins(match.group(3))
            if name in totals:
              self.warn("DROPPING duplicate name '", name, "' in '", self.totals_path, "':\n",
                   line, '\n')
              continue
            totals[name] = minutes
          except Timelog.InvalidNameError as e:
            self.warn("DROPPING invalid name in '", self.totals_path, "': '", name, "'")
            pass
        if not lines[-1].endswith('\n'):
          append_to_file(self.totals_path, '\n')
      self.totals = totals
    return self.totals


  def add_project_name(self, name, lock):
    self.validate_project_name(name)
    with lock:
      self.get_totals()
      if name in self.totals:
        self.err("Already exists: '", name, "'")
      self.totals[name] = 0
      lines = [('%s=%s\n'%(name,mins2str(minutes)))
               for name, minutes in sorted(self.totals.iteritems())]
      write_file(self.totals_path, ''.join(lines))

  def add_timing(self, timing):
    timings_file = self.year()
    timings_file.add_timing(timing)
    self.get_totals()
    name = timing.name
    self.totals[name] = (self.totals.get(name) or 0) + timing.minutes

      

  class TimingsFile(Notify):
    def __init__(self, notify_func, path):
      Notify.__init__(self, notify_func)
      self.path = path
      self.entries = None
      self.totals = None
      self.initial_totals = None

    def read(self):
      try:
        lf = open(self.path, "r")
      except:
        if not os.path.exists(self.path):
          return
        raise

      try:
        self.entries = []
        self.totals = {}
        self.initial_totals = {}

        line_count = 0

        # read initial totals
        while True:
          at = lf.tell()
          line = lf.readline()
          line_count += 1
          match = Regex.match(LOG_INITIAL_TOTAL_RE, line)
          if match:
            name = match.group(1)
            Timelog.validate_project_name(None, name)
            minutes = str2mins(match.group(2))
            self.initial_totals[name] = (
                (self.initial_totals.get(name) or 0) + minutes )
          else:
            lf.seek(at) # unread last line, continue below.
            line_count -= 1
            break

        while True:
          line = lf.readline()
          line_count += 1
          if not line:
            break

          t = Timing().deserialize(line)
          if t:
            self.entries.append(t)
            continue

          self.warn('cannot parse line ', line_count, ' in timelog file ', 
                    self.path)
      finally:
        lf.close()

    def add_timing(self, timing):
      assert(isinstance(timing, Timing))
      if timing.minutes == 0:
        return
      append_to_file(self.path, timing.serialize())
      if self.totals is None:
        self.totals = {}
      self.totals[timing.name] = ((self.totals.get(timing.name) or 0)
                                  + timing.minutes)

  def path_for_year(self, year):
    return j(self.timelog_base_path, str(int(year)))

  def year(self, year=None):
    if year is None:
      year = time2year(now())
    year = int(year)
    timings_file = self.timelog_files.get(year)
    if not timings_file:
      timings_file = Timelog.TimingsFile(self.notify_func,
                                         self.path_for_year(year))
      self.timelog_files[year] = timings_file
    return timings_file
    




class TimedDirLock(Notify):
  id_count = 0

  def __init__(self, notify_func, lock_path,
               sleep_time_in_seconds=1.0, timeout=30, valid_for=10):
    Notify.__init__(self, notify_func)
    self.lock = self.__enter__
    self.unlock = self.__exit__
    self.lock_path = lock_path
    self.sleep_time_in_seconds = sleep_time_in_seconds
    self.timeout = timeout
    self.valid_for = valid_for
    self.acquired = None
    self.id_file = j(self.lock_path, 'pid')
    self.id = TimedDirLock.id_count
    TimedDirLock.id_count += 1
    self.lock_count = 0


  class LockError(Error):
    pass

  def get_lock_creation_time(self):
    try:
      return os.path.getmtime(self.lock_path)
    except OSError as e:
      if e.errno == errno.ENOENT:
        return None
      raise

  def remove_stale_lock(self, kill_process=True):
    at = self.get_lock_creation_time()
    pid = None
    if (at is not None) and (now() - int(at) > self.valid_for):
      self.msg("Removing stale lock '%s'" % self.lock_path)
      if not gently_kill_process(self.locked_by_pid()):
        raise TimedDirLock.LockError(msgs2str(
                'Unable to kill locking process (', pid, ')'))

      # process is gone. Remove the lock files.
      try:
        shutil.rmtree( self.lock_path )
      except OSError as e:
        if e.errno != errno.ENOENT:
          raise
    return pid

  def __enter__(self):
    if self.acquired:
      self.lock_count += 1
      return
    dirname = os.path.dirname(self.lock_path)
    if not os.path.isdir(dirname):
      os.makedirs(dirname)
    at = now()
    while True:
      try:
        os.mkdir(self.lock_path)
        break
      except OSError as e:
        if e.errno == errno.EEXIST:
          if ((not self.remove_stale_lock())
              and (now() > (at + self.timeout))):
            raise TimedDirLock.LockError(msgs2str(
                'Timeout when trying to acquire lock \'',
                self.lock_path, "' from process ", self.locked_by_pid()))
          time.sleep(self.sleep_time_in_seconds)
          continue
        else:
          raise
    # I got the lock!
    self.acquired = now()
    self.lock_count = 1
    write_file(self.id_file, self.own_id())

  def own_id(self):
    return ':'.join((str(os.getpid()), str(self.id)))

  def locked_by_id(self):
    return read_file(self.id_file)

  def locked_by_pid(self):
    x = self.locked_by_id()
    if ':' in x:
      return int(x.split(':')[0])
    return int(x)

  def verify_lock(self, strict=False, refresh=True):
    if not self.acquired:
      if strict:
        raise TimedDirLock.LockError(msgs2str(
                "Unlock: am not locked to '", self.lock_path, "'"))
      return False
    check = self.locked_by_id()
    if (not check) or (check != self.own_id()):
      self.acquired = None
      self.lock_count = 0
      self.warn("lost lock '", self.lock_path, "'")
      return False
    if refresh:
      os.utime(self.lock_path, None)
    return True

  def __exit__(self, *ignored_args):
    if self.verify_lock(strict=True):
      if self.lock_count > 1:
        self.lock_count -= 1
        return
      self.acquired = None
      self.lock_count = 0
      shutil.rmtree(self.lock_path)

  def __del__(self):
    self.__exit__()


class Tim(Notify):
  config_dir = j(os.environ['HOME'], '.tim')
  state_file_path = j(config_dir, 'running')
  timelog_dir = j(config_dir, 'daemon_pid')
  seconds_per_minute = 60.0
  stale_threshold = 5 * seconds_per_minute

  def __init__(self, notify_func):
    Notify.__init__(self, notify_func)
    self.notify = self.notify_func
    self.timelog = Timelog( notify_func, j(Tim.config_dir, 'timelog') )
    self.lock = TimedDirLock( notify_func, j(Tim.config_dir, 'lock') )
    pid = self.lock.remove_stale_lock()

  def find_full_name(self, name):
    totals = self.timelog.get_totals()
    if name in totals:
      return name
      
    matches = set()
    for known_name in totals:
      tokens = known_name.split('.')
      while tokens:
        if name == tokens[-1]:
          matches.add('.'.join(tokens))
        del tokens[-1]
    if len(matches) > 1:
      self.err("Multiple matches found for '", name, "':\n",
               '\n'.join(sorted(matches)))
    elif len(matches) == 1:
      return matches.pop()
    else:
      return None


  def new(self, name):
    self.timelog.add_project_name(name, self.lock)
    self.msg("Added '", name, "'")

  def stop(self, comment=None):
    stopped_state = None
    with self.lock:
      stopped_state = State()
      t = stopped_state.timing
      if t.started:
        if comment:
          if t.comment:
            t.comment = ' '.join((t.comment, comment))
          else:
            t.comment = comment
        self.timelog.add_timing(t)
        # clear the state on disk
        empty_state = State(read=False)
        empty_state.save()
      else:
        stopped_state = None # nothing was stopped
    if stopped_state:
      self.notify(Notify.STOPPED, stopped_state)
    return stopped_state

  def handle_stale_state(self, state):
    """see if the daemon was interrupted (e.g. box suspended).
    If so, don't count the time that the daemon was suspended, or
    stop everything, depending on how much time has passed."""
    if state.is_stale():
      self.notify(Notify.STALE, state)
      if not gently_kill_process(state.pid):
        self.warn('Unable to kill timer process (', pid, ')')
      # assume the user forgot about me, and exit.
      self.stop()
      # Reload.
      state.read()

  def get_status(self):
    with self.lock:
      state = State()
      if state.timing.started:
        self.handle_stale_state(state)
      return state

  def start(self, name_to_start):
    ''' name_to_start: fully resolved project name ('root.bar.baz') '''

    with self.lock:
      state = State()

    t = state.timing
    if t.started:
      if t.name == name_to_start:
        self.notify(Notify.ALREADY_RUNNING, name_to_start)
        return True
      self.stop()

    self.notify(Notify.STARTED, name_to_start)

    daemon_out = open('daemon.log', 'a+')
    with daemon.DaemonContext(
             stdout=daemon_out, stderr=daemon_out,
           ):
      try:
        my_pid = os.getpid()

        original_starting_time = str2time( time2str( now() ) )

        state = State(read=False)
        state.set_values(
          name=name_to_start,
          started=original_starting_time,
          minutes=1,  # <-- debug  minutes=0,
          pid=my_pid)
        with self.lock:
          state.save()

        while True:
          # try to run just after the break of the minute
          time.sleep(Tim.seconds_per_minute + 1
                     - (now() % Tim.seconds_per_minute))

          with self.lock:
            # verify that the state still shows the same starting time that
            # I was called to act on.
            state.read()
            t = state.timing
            if t.started:
              self.handle_stale_state(state)
            if not (state.pid == my_pid
                    and t.started == original_starting_time
                    and t.name == name_to_start):
              # the current state no longer concerns me.
              return

            # all is well, update the state
            t.minutes = ((int(now()) - t.started) 
                         / Tim.seconds_per_minute)
            state.save()
      finally:
        _msg('daemon done')

  def get_log(self, start_date=None, end_date=None):
    year = self.timelog.year( time2year(now()) )
    year.read()
    return year


# invocation via commandline #################################################

class TimCmdline:
  def __init__(self, args):
    self.tim = Tim(self.notify)
    self.args = args

    if any([(arg in args)
            for arg in ('-h', '--help', '-?', '-help', 'help')]):
      self.usage()

    if not args:
      # when called without arguments show status
      function = self.cmd_status
    else:
      cmd = args[0]
      func_name = 'cmd_' + cmd

      function = None
      if hasattr(self, func_name):
        function = getattr(self, func_name)
      if not callable(function):
        # convenience: omit 'start' for known project names
        if len(args) == 1:
          return self.cmd_start(*args)
        _raise("Unknown command: '", cmd, "'\ntry: 'tim help'")

    return function(*(args[1:]))

  def usage(self, error_message=None):
    _msg(__doc__)
    if (error_message):
      errmsg(error_message)
      exit(1)
    exit(0)

  def cmd_new(self, *args):
    if len(args) > 1:
      _raise("'new' takes only one argument: an unknown name.")
    self.tim.new(args[0])

  def notify(self, key, arg):
    if key == Notify.ALREADY_RUNNING:
      name = str(arg)
      _warn('Already running: ', name)
    elif key == Notify.STOPPED:
      state = arg
      t = state.timing
      _msg('Stopped ', t.name,
           ' (', mins2str(t.minutes), ')')
    elif key == Notify.STARTED:
      name = str(arg)
      _msg('Started ', name)
    elif key == Notify.MSG:
      msg = arg
      _msg(msg)
    elif key == Notify.WARN:
      msg = arg
      _warn(msg)
    elif key == Notify.ERROR:
      msg = arg
      _raise(msg)
    elif key == Notify.STALE:
      state = arg
      t = state.timing
      _warn('detected undead timer!',
            '\nStopped timer, not counting interrupted time.',
            '\n         name: ', t.name,
            '\n      started: ', time2str(t.started),
            '\n      ran for: ', mins2str(t.minutes),
            '\n  interrupted: ', mins2str((now()-t.started)/60),
              ' hours ago',
            )

  def cmd_start(self, *args):
    if len(args) > 1:
      _raise("'start' takes only one argument: a name.")
    name = self.tim.find_full_name(args[0])
    if not name:
      _raise("Unknown name: '", args[0], "' -- ",
             "try 'tim new ", args[0], "' first?")
    self.tim.start(name)

  def cmd_stop(self, *args):
    comment = ' '.join(args)
    stopped_state = self.tim.stop(comment)
    # notification
    if not stopped_state:
      _raise('No timer is running.')

  def cmd_status(self, *args):
    if args:
      _raise("'status' takes no arguments")
    status = self.tim.get_status()
    t = status.timing
    if t.started:
      _msg('Running: ', t.name, '=', mins2str(t.minutes), ' (since ',
           time2str(t.started), ')')
    else:
      _msg('Not running.')

  def cmd_totals(self, *args):
    selected = None
    if args:
      selected = [self.tim.find_full_name(arg) for arg in args]
    totals = self.tim.timelog.get_totals()
    if totals:
      msg('Totals:')
      def show(name, val):
        mins_str = mins2str(val)
        if not ':' in mins_str:
          mins_str = '%6s   ' % mins_str
        else:
          mins_str = '%9s' % mins_str
        msg(mins_str, ' ', name)
      grand_total = 0
      for name, val in sorted(totals.iteritems()):
        if (not selected) or (name in selected):
          grand_total += val
          show(name, val)
      msg('=========')
      show('all', grand_total)
    else:
      msg('Nothing is recorded.')

  def cmd_log(self, *args):
    if args:
      _raise("'log' arguments not implemented")

    log = self.tim.get_log()
    for entry in log.entries:
      _msg(str(entry))

if __name__ == "__main__":
  # run commandline client.

  try:
    TimCmdline(sys.argv[1:])
  except Error, e:
    errmsg(str(e))
    print
    raise #exit(-1)

