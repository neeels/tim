#!/usr/bin/env python
# coding: utf8
#
# Tim
# ===
# 
# project timer (GUI + cmdline)
# 
# You enter project names and start and stop them.
# Tim will keep track of how much you worked (and when) and how many of these
# worked hours you have already submitted to your money supplier.
# 
# (c) Copyright 2013 by Neels Janosch Hofmeyr <neels@hofmeyr.de> (GPLv3)
# 
# This file is part of Tim project timer.
# 
# Tim project timer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tim project timer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tim project timer.  If not, see <http://www.gnu.org/licenses/>.

__doc__ = '''Tim project timer.

You enter names and start and stop them. Tim tracks how much you worked on
which (and when) and, if you like, how many of these worked hours you have
already submitted to your money supplier.

usage:
  tim systray
  tim new <project-name>
  tim [start] <project-name> [<comment>]
  tim [running]
  tim [adjust] [@<started-time>|+<duration>|-<duration>|=<duration>]
  tim stop [<comment>]
  tim totals [-l <name>]
  tim log [-l <name>] [-s <date>] [-d|-w|-m|-y] [-D|-W|-M|-Y] [-n <nr>]
  tim tickoff <hours> [<project-name>] 
  tim tickoff --undo
  tim rename <current-project-name> <new-project-name>
  tim forget <project-name>
  tim remember [<id>] [--as <project-name>] [--add-to <project-name>]


--- tim systray ---
Launch a systray icon. Put this in your window manager's autostart.

--- tim new ---
Announce a new project name. You can use dots '.' to create subgroups of
projects.
  tim new foo
  tim new yoyodyne.abc

--- tim start ---
When you start working on a given project, call 'tim start myprojectname'.
The word 'start' can be omitted. Before you can start a project, you must tell
Tim about with the 'tim new' command.

Project names names can be grouped, simply by inserting dots in the name. Any
number of grouping levels is allowed.

As soon as the project name is known ('tim start mygroup.myname'), you only
need to type the part after the last dot ('tim myname'), as long as it does
not have the same name as any other project in any other group.

--- tim running ---
Show the current timer, if any is running. This is the same as calling 'tim'
without any arguments.

--- tim adjust ---
When a timer is currently running, adjust the recorded time. This always
shifts the started-time so that the desired duration results when counting up
to the current moment in time. The word 'adjust' may be omitted.
  @<started-time>
    I have actually started working on this project at <started-time>.
    Adjust the timing counter for the current project accordingly.
    <started-time> format is 'HH:MM', e.g. '14:59'. Wraps past midnight
    (yesterday's time is used when today's time would be in the future).
      tim @9      # make as if I called 'start' at 9 o'clock this morning
      tim @15:30  # ... at half past three. 
  +<duration>
    Add <duration> to the currently running timer.
    <duration>: [HH][:MM], for example:
      tim +1      # add one hour
      tim +1:30   # add one and a half hours
      tim +1.5    # add one and a half hours (decimal dot)
      tim +:30    # add thirty minutes
  -<duration>
    Subtract <duration>. '- 10' is the same as '-10' and '+ -10'.
  =<duration>
    Set the current counter to exactly <duration> hours.
      tim =1      # make as if I called 'start' one hour ago

--- tim stop ---
Stop the currently running timer. Any arguments after the word 'stop' are
stored as a comment for the hours just worked.

--- tim totals ---
Print the current timing totals of hours spent vs. hours ticked-off on a
per-group and per-project basis.
  -l <name>
    Limit the listing to this project (or group).

--- tim log ---
Show the timings for this week (-W is the default). Options:
  -l <name>
    Limit the listing to this project (or group).
  Time options:
    default: show each timing in hours and minutes
    -d/-w/-m/-y  combine hours for each day/week/month/year
    -D/-W/-M/-Y  start at the beginning of this day/week/month/year
    -f  start one full time period ago, flowing, floating past boundaries.
        For example, '-f -W' starts seven days ago, instead of last monday;
        '-f -M' starts the same day last month, instead of this month's 1st.
    -n <nr>
       Repeat above time period for <nr> times into the past.
  -s <date>
    Start at <date>, of format 'YYYY-MM-DD_hh:mm', where everything left and
    right of 'hh' may be omitted.
      -s 2013-01-11
        Start at 00:00 on 11th of January, 2013.
      -s 2013-01-11_23:45
        Start at 23:45 on 11th of January, 2013.
      -s 10
        Same as '-s 10:00', start 10 o'clock today
      -s 1_
        Same as '-s 1_0:00', start on the first day of this month
      -s 1-1_
        Same as '-s 1-1_0:00', start on the most recent 1st of January
      -s 3-32_
        Same as '-s 4-1_0:00', start on the most recent 1st of April (wrap!)
      (etc.)

--- tim tickoff ---
Record hours that you have already billed your money supplier for. If you are
timing private / hobby projects, your total hours will simply grow. But if you
have an employer, ticking off is useful to keep track of how many hours you
have actually passed on to your employer's accounting. If you are using
tickoff for any given project, you probably want to reach a total of zero for
that project at regular intervals. If you've worked less than you billed, your
total hours become negative.
- If no project name is supplied, the tickoff is chronologically spread across
  all projects, so that the hours worked longest ago are ticked off first.
    tim tickoff 32
- You can tickoff a group (yoyodyne), in which case the hours contained in any
  sub-projects and sub-sub-projects are ticked-off in their chronological
  order (see examples below). You can also tickoff subprojects specifically.
    tim tickoff 32 yoyodyne
- If a group's total is negative, I've already billed hours I haven't worked
  yet; over time, sub-projects of such a group will receive new hours, but the
  negative total of the parent will only be neutralised at the next tickoff
  command. You may call 'tim tickoff 0 mygroupname' to chronologically
  neutralise a negative total with hours worked in sub-projects.
    tim tickoff 0 yoyodyne  # neutralise negative total with sub-projects
- If you want to keep strictly separate project groups, you should take
  care to never omit the group name when calling the tickoff command. If it
  should go wrong one day, you can undo tickoffs one by one with:
    tim tickoff --undo

--- tim rename ---
Rename a project while keeping its hours and logs. This may also move projects
around between groups.
Note that this changes the name in all logs back to the start of time, so the
'tim log' command will not look the same as before.

--- tim forget ---
Remove a given project from accounting. The data will still be sitting in the
database, but it will appear to be completely removed with all its history
when interacting with tim.

--- tim remember ---
Recover a project previously forgotten with 'tim forget'. Run without
arguments to get a listing of IDs for forgotten projects or groups.

--- EXAMPLE ---
  This example shows a sequence of tim commands. Imagine that time passes
  between each pair of start ... stop commands.
  
  tim new foo
  tim foo
  tim stop
  tim foo
  tim stop

  tim new yoyodyne.abc     # announce project abc in group yoyodyne
  tim yoyodyne.abc         # start timing for project abc in the group yoyodyne
  tim +1                   # fake starting-time so that I've worked 1 hour now
  tim stop "fix a bug"     # stop timing, record in the log with a message
  tim abc                  # start yoyodyne.abc; tim finds 'abc' in 'yoyodyne'.
  tim stop
  tim new yoyodyne.xyz.bar # announce project bar in new group yoyodyne.xyz
  tim xyz                  # start yoyodyne.xyz (yes, "groups" can also start)
  tim abc                  # stop yoyodyne.xyz, start yoyodyne.abc, in one go
  tim stop

  tim log                  # show the log of this week (starting monday)
  tim log -w -n 5          # show last five weeks (five times seven days)
  tim log yoyodyne         # show log for yoyodyne.* projects only

  tim totals               # show the sum of all hours for all projects
  tim tickoff 32 yoyodyne  # I have billed yoyodyne for 32 hours.
  tim totals               # Above 32 hours are now subtracted from the totals.
 '''

import re, os, errno, time, shutil, sys, signal
import daemon
import lockfile
from os.path import join as j
from time import time as now


# messaging and error handling ###############################################

def msgs2str(msgs):
  return ''.join([str(m) for m in msgs])

class Error(Exception):
  def __init__(self, *msgs):
    self.msg = msgs2str(msgs)
  def __str__(self):
    return self.__class__.__name__ + ': ' + self.msg

def err(*msgs):
  raise Error(*msgs)

def warn(*msgs):
  print '***', msgs2str(msgs)

def msg(*msgs):
  print msgs2str(msgs)

def errmsg(*msgs):
  sys.stderr.write('tim: ')
  for msg in msgs:
    sys.stderr.write(msg)
  sys.stderr.write('\n')
  sys.stderr.flush()
  

# generic conversion functions ###############################################

def mins2str(float_mins):
  sign = 1
  frac = 59.0
  if float_mins < 0:
    float_mins = -float_mins
    sign = -1
    frac = 1.0
  
  minutes = int(float_mins)
  if float_mins - float(minutes) > (frac/60):
    minutes += 1

  h, m = divmod(minutes, 60)

  if m == 0:
    return str(sign * h)
  elif sign < 0:
    # just 'h *= sign' won't work if h == 0.
    return "-%d:%02d" % (h,m)
  else:
    return "%d:%02d" % (h,m)

def str2mins(str_hours):
  try: 
    if str_hours.find(':') < 0:
      return int(round(float(str_hours) * 60.0))

    h, m = str_hours.split(':')
    sign = 1
    if h.startswith('+'):
      h = h[1:]
    if h.startswith('-'):
      h = h[1:]
      sign = -1

    if not h or len(h) < 1:
      fh = 0
    else:
      fh = float(h)

    if not m or len(m) < 1:
      fm = 0
    else:
      fm = float(m)

    return int(sign * round(fh * 60.0 + fm))
  except Exception, e:
    err("Time format error, not a time string: ", str_hours or "None")

TIMESTR_FORMAT = "%Y-%m-%d %H:%M"

def time2str(float_time):
  if not float_time:
    return None
  return time.strftime(TIMESTR_FORMAT, time.localtime(float(float_time)))

def str2time(str):
  if not str or len(str) < 1:
    return None
  return time.mktime( time.strptime(str, TIMESTR_FORMAT) )

def time2year(float_time):
  return int(time.strftime('%Y', time.localtime(float_time)))


# os file & process functions ################################################

def write_file(path, contents, mkdirs=True):
  if mkdirs:
    dirname = os.path.dirname(path)
    if not os.path.exists(dirname):
      os.makedirs(dirname)
  f = open(path, "w")
  f.write(contents)
  f.close()

def append_to_file(path, *contents):
  f = open(path, "a")
  for c in contents:
    f.write(c)
  f.close()

def read_file(path):
  try:
    f = open(path, "r")
    contents = f.read()
    f.close()
    return contents
  except IOError:
    return None

def read_file_lines(path):
  try:
    f = open(path, "r")
    contents = f.readlines()
    f.close()
    return contents
  except IOError:
    return None

def process_is_running(pid):
  try:
    os.kill(int(pid), 0)
    return True
  except OSError as e:
    if e.errno == errno.ESRCH: # no such process
      return False
    raise

def gently_kill_process(pid):
  if not (pid and process_is_running(pid)):
    return True
  msg('kill -SIGINT ', pid)
  os.kill(pid, signal.SIGINT)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  msg('kill -SIGTERM ', pid)
  os.kill(pid, signal.SIGTERM)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  msg('kill -SIGKILL ', pid)
  os.kill(pid, signal.SIGKILL)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  return False
 

# classes implementing Tim ###################################################

class Timelog:
  INIT_STR = 'init:'
  TICKOFF_STR = 'tickoff:'
  NAME_RE = '([a-zA-Z_][a-zA-Z0-9_]*\.)*[a-zA-Z_][a-zA-Z0-9_]*'
  TIME_RE = '[+-]{0,1}[0-9:]+'
  DATE_RE = r'(\d{1,4})-(\d{1,2})-(\d{1,2})[_ ](\d{1,2})[-:](\d{1,2})'
  NAME_STR_RE = '\A' + NAME_RE + '\Z'
  LOG_INITIAL_TOTAL_RE = '^' + INIT_STR + ' *([^ *])=(' + TIME_RE + ')$'
  LOG_ENTRY_RE = '^' + DATE_RE + '[: ]+([^ ]+) (' + TIME_RE + ')($| (.*)$)'
  LOG_TICKOFF_RE = '^' + DATE_RE + ' ' + TICKOFF_STR + ' (' + NAME_RE + ') (' + TIME_RE + ')$'
  TOTALS_LINE_RE = '^(' + NAME_RE + ')=(' + TIME_RE + ')$'

  def __init__(self, timelog_base_path):
    self.timelog_base_path = timelog_base_path
    self.totals_path = j(self.timelog_base_path, 'totals')
    self.clear()

  def clear(self):
    self.timelog_files = {}
    self.totals = None

  class InvalidNameError(Error):
    pass

  def validate_project_name(self, name):
    if not re.match(Timelog.NAME_STR_RE, name):
      raise Timelog.InvalidNameError("Invalid name for a project: '", name,
               "'\n(only letters, numbers and '_' allowed in project names,",
               " separated by '.',\nnumbers may not appear at the start.)")

  def get_totals(self):
    if self.totals is None:
      totals_re = re.compile(Timelog.TOTALS_LINE_RE)
      lines = read_file_lines(self.totals_path)
      totals = {}
      if lines:
        for line in lines:
          try:
            match = totals_re.match(line)
            if not match:
              warn("DROPPING invalid line in '", self.totals_path, "':\n", line, '\n')
              continue
            name = match.group(1)
            self.validate_project_name(name)
            minutes = str2mins(match.group(3))
            if name in totals:
              warn("DROPPING duplicate name '", name, "' in '", self.totals_path, "':\n",
                   line, '\n')
              continue
            totals[name] = minutes
          except Timelog.InvalidNameError as e:
            warn("DROPPING invalid name in '", self.totals_path, "': '", name, "'")
            pass
        if not lines[-1].endswith('\n'):
          append_to_file(self.totals_path, '\n')
      self.totals = totals
    return self.totals


  def add_project_name(self, name, lock):
    self.validate_project_name(name)
    with lock:
      self.get_totals()
      if name in self.totals:
        err("Already exists: '", name, "'")
      self.totals[name] = 0
      lines = [('%s=%s\n'%(name,mins2str(minutes)))
               for name, minutes in sorted(self.totals.iteritems())]
      write_file(self.totals_path, ''.join(lines))

  def add_timing(self, state):
    timing = Timelog.Timing(kind=Timelog.Timing.KIND_TIMING,
                            started=state.started,
                            name=state.name,
                            minutes=state.minutes,
                            comment=state.comment)
    timings_file = self.year()
    timings_file.add_timing(timing)
    self.get_totals()
    name = timing.name
    self.totals[name] = (self.totals.get(name) or 0) + timing.minutes

  class Timing:
    KIND_TIMING = 0
    KIND_TICKOFF = 1

    def __init__(self, **kwargs):
      self.set_values(**kwargs)
    def set_values(self, kind=None, started=None, name=None, minutes=None,
                         comment=None):
      self.kind = kind
      self.started = started
      self.name = name
      self.minutes = minutes
      self.comment = comment
      if not self.comment:
        self.comment = None
      return self
    def verbose(self):
      msg('started=', time2str(self.started), ' name=', self.name,
          ' minutes=', mins2str(self.minutes), ' comment=', self.comment)
      return self
    def __str__(self):
      if self.started:
        started_str = time2str(self.started)
      else:
        started_str = 'not_started'
      elts = [started_str,
              self.name or 'unnamed',
              mins2str(self.minutes or 0)]
      if self.comment:
        elts.append(self.comment)
      return ' '.join(elts)
      

  class TimingsFile:
    def __init__(self, path):
      self.path = path
      self.entries = None
      self.totals = None
      self.initial_totals = None

    def read(self):
      try:
        lf = open(self.path, "r")
      except:
        if not os.path.exists(self.path):
          return
        raise

      try:
        self.entries = []
        self.totals = {}
        self.initial_totals = {}

        # read initial totals
        while True:
          at = lf.tell()
          line = lf.readline()
          match = re.match(Timelog.LOG_INITIAL_TOTAL_RE, line)
          if match:
            name = match.group(1)
            Timelog.validate_project_name(None, name)
            minutes = str2mins(match.group(2))
            self.initial_totals[name] = (
                (self.initial_totals.get(name) or 0) + minutes )
          else:
            lf.seek(at) # unread last line, continue below.
            break

        entry_re = re.compile(Timelog.LOG_ENTRY_RE)
        tickoff_re = re.compile(Timelog.LOG_TICKOFF_RE)

        while True:
          line = lf.readline()
          if not line:
            break

          match = entry_re.match(line)
          if match:
            self.entries.append(
              Timelog.Timing(
                started=str2time('%s-%s-%s %s:%s' % match.groups()[0:5]),
                name=match.group(6),
                minutes=str2mins(match.group(7)),
                comment=match.group(8),
                )
               )
            continue

          match = tickoff_re.match(line)
          if match:
            print 'tickoff', match.groups()
            continue
      finally:
        lf.close()

    def add_timing(self, timing):
      assert(isinstance(timing, Timelog.Timing))
      if timing.minutes = 0:
        return
      append_to_file(self.path, str(timing), '\n')
      if self.totals is None:
        self.totals = {}
      self.totals[timing.name] = ((self.totals.get(timing.name) or 0)
                                  + timing.minutes)

  def path_for_year(self, year):
    return j(self.timelog_base_path, str(int(year)))

  def year(self, year=None):
    if year is None:
      year = time2year(now())
    year = int(year)
    timings_file = self.timelog_files.get(year)
    if not timings_file:
      timings_file = Timelog.TimingsFile(self.path_for_year(year))
      self.timelog_files[year] = timings_file
    return timings_file
    




class TimedDirLock:
  id_count = 0

  def __init__(self, lock_path, sleep_time_in_seconds=1.0, timeout=30, valid_for=10):
    self.lock = self.__enter__
    self.unlock = self.__exit__
    self.lock_path = lock_path
    self.sleep_time_in_seconds = sleep_time_in_seconds
    self.timeout = timeout
    self.valid_for = valid_for
    self.acquired = None
    self.id_file = j(self.lock_path, 'pid')
    self.id = TimedDirLock.id_count
    TimedDirLock.id_count += 1
    self.lock_count = 0


  class LockError(Error):
    pass

  def err(self, *msgs):
    raise TimedDirLock.LockError(*msgs)

  def get_lock_creation_time(self):
    try:
      return os.path.getmtime(self.lock_path)
    except OSError as e:
      if e.errno == errno.ENOENT:
        return None
      raise

  def remove_stale_lock(self, kill_process=True):
    at = self.get_lock_creation_time()
    pid = None
    if (at is not None) and (now() - int(at) > self.valid_for):
      msg("Removing stale lock '%s'" % self.lock_path)
      if not gently_kill_process(self.locked_by_pid()):
        err('Unable to kill locking process (', pid, ')')

      # process is gone. Remove the lock files.
      try:
        shutil.rmtree( self.lock_path )
      except OSError as e:
        if e.errno != errno.ENOENT:
          raise
    return pid

  def __enter__(self):
    if self.acquired:
      self.lock_count += 1
      return
      #self.err("Already locked to '", self.lock_path, "'")
    dirname = os.path.dirname(self.lock_path)
    if not os.path.isdir(dirname):
      os.makedirs(dirname)
    at = now()
    while True:
      try:
        os.mkdir(self.lock_path)
        break
      except OSError as e:
        if e.errno == errno.EEXIST:
          if ((not self.remove_stale_lock())
              and (now() > (at + self.timeout))):
            self.err('Timeout when trying to acquire lock \'', self.lock_path, "' from process ", self.locked_by_pid())
          time.sleep(self.sleep_time_in_seconds)
          continue
        else:
          raise
    # I got the lock!
    self.acquired = now()
    self.lock_count = 1
    write_file(self.id_file, self.own_id())

  def own_id(self):
    return ':'.join((str(os.getpid()), str(self.id)))

  def locked_by_id(self):
    return read_file(self.id_file)

  def locked_by_pid(self):
    x = self.locked_by_id()
    if ':' in x:
      return int(x.split(':')[0])
    return int(x)

  def verify_lock(self, strict=False, refresh=True):
    if not self.acquired:
      if strict:
        self.err("Unlock: am not locked to '", self.lock_path, "'")
      return False
    check = self.locked_by_id()
    if (not check) or (check != self.own_id()):
      self.acquired = None
      self.lock_count = 0
      warn("lost lock '", self.lock_path, "'")
      return False
    if refresh:
      os.utime(self.lock_path, None)
    return True

  def __exit__(self, *ignored_args):
    if self.verify_lock(strict=True):
      if self.lock_count > 1:
        self.lock_count -= 1
        return
      self.acquired = None
      self.lock_count = 0
      shutil.rmtree(self.lock_path)

  def __del__(self):
    self.__exit__()


class Tim:
  config_dir = j(os.environ['HOME'], '.tim')
  state_file_path = j(config_dir, 'state')
  timelog_dir = j(config_dir, 'daemon_pid')
  seconds_per_minute = 60.0
  stale_threshold = 5 * seconds_per_minute
  very_stale_threshold = 100 * seconds_per_minute
  ALREADY_RUNNNG = 0
  STARTED = 1
  STOPPED = 2

  def __init__(self):
    self.timelog = Timelog( j(Tim.config_dir, 'timelog') )
    self.lock = TimedDirLock( j(Tim.config_dir, 'lock') )
    pid = self.lock.remove_stale_lock()

  class State:
    STOPPED = 'stopped'
    SEP = '#'

    def __init__(self, read=True, state_file_path=None):
      self.state_file_path = state_file_path or Tim.state_file_path
      if self.state_file_path and read:
        self.read()
      else:
        self.clear()

    def clear(self):
      self.started = None
      self.name = None
      self.minutes = None
      self.comment = None
      self.pid = None

    def is_stale(self):
      assert(self.started)

      expected_now = self.started + (self.minutes * Tim.seconds_per_minute)

      timestep = now() - expected_now
      if timestep > Tim.stale_threshold:
        if timestep < Tim.very_stale_threshold:
          # hm, there has been a shortish break in the daemon's execution.
          # Let's record the previous bit and start a new one.
          return 1  # a bit stale
        else:
          # wow, I was out for very long.
          # assume the user forgot about me, and exit.
          return 2  # very stale
      return 0  # not stale


    def started_str(self):
      return time2str(self.started)

    def __str__(self):
      if self.started:
        return Tim.State.SEP.join([self.started_str() or '',
                                   self.name or '',
                                   mins2str(self.minutes or 0),
                                   str(self.pid),
                                   self.comment or ''])
      else:
        return Tim.State.STOPPED

    def read(self):
      self.clear()

      if not os.path.isfile(self.state_file_path):
        return False

      statestr = read_file(self.state_file_path)
      if statestr is None:
        return False
      statestr = statestr.strip()

      if statestr == Tim.State.STOPPED:
        # no data.
        return True

      tokens = statestr.split(Tim.State.SEP)
      if len(tokens) < 4:
        # no complete state
        return False

      self.started = str2time(tokens[0]) # date string to unix time
      self.name = tokens[1]              # string
      self.minutes = str2mins(tokens[2]) # HH:MM string to float in minutes
      self.pid = int(tokens[3])

      if len(tokens) > 4:
        self.comment = Tim.State.SEP.join(tokens[4:])

      return True

    def save(self):
      "write this state to file"
      write_file(self.state_file_path, str(self) + '\n')
      return self


  def find_full_name(self, name):
    totals = self.timelog.get_totals()
    if name in totals:
      return name
      
    matches = set()
    for known_name in totals:
      tokens = known_name.split('.')
      while tokens:
        if name == tokens[-1]:
          matches.add('.'.join(tokens))
        del tokens[-1]
    if len(matches) > 1:
      err("Multiple matches found for '", name, "':\n",
          '\n'.join(sorted(matches)))
    elif len(matches) == 1:
      return matches.pop()
    else:
      return None


  def new(self, name):
    self.timelog.add_project_name(name, self.lock)
    msg("Added '", name, "'")

  def stop(self, comment=None):
    with self.lock:
      state = Tim.State()
      if state.started:
        if comment:
          if state.comment:
            state.comment = ' '.join((state.comment, comment))
          else:
            state.comment = comment
        self.timelog.add_timing(state)
        # clear the state on disk
        empty_state = Tim.State(read=False)
        empty_state.save()
        # return the stopped in-memory state
        return state
    return None

  def handle_stale_state(self, state):
    """see if the daemon was interrupted (e.g. box suspended).
    If so, don't count the time that the daemon was suspended, or
    stop everything, depending on how much time has passed."""

    stale = state.is_stale()
    if stale:
      if stale == 1:
        stale_action_msg = 'Restarted timer, not counting interrupted time.'
      elif stale == 2:
        stale_action_msg = 'Stopped timer, not counting interrupted time.'
      warn('detected undead timer!',
           '\n         name: ', state.name,
           '\n      started: ', time2str(state.started),
           '\n      ran for: ', mins2str(state.minutes),
           '\n  interrupted: ', mins2str((now()-state.started)/60),
             ' hours ago',
           '\n           --> ', stale_action_msg)
      if not gently_kill_process(state.pid):
        warn('Unable to kill locking process (', pid, ')')
      if stale == 1:
        # hm, there has been a shortish break in the daemon's execution.
        # Let's record the previous bit and start a new one.
        self.stop()
        self.start(state.name)
      elif stale == 2:
        # wow, I was out for very long.
        # assume the user forgot about me, and exit.
        self.stop()
      # if it was stale, the state was changed to fix staleness. Reload.
      state.read()

  def get_status(self):
    with self.lock:
      state = Tim.State()
      if state.started:
        self.handle_stale_state(state)
      return state

  def start(self, name_to_start, reporter_func=None):
    '''
    name_to_start: fully resolved project name ('root.bar.baz')
    reporter_func(key, name): function that notifies the user; the calling code
    can/should print these messages on screen in some way or other.
    key: Tim.ALREADY_RUNNNG, Tim.STARTED or Tim.STOPPED
    name: the project name that is already running / was started / was stopped.
    A callback mechanism is used since this function becomes a daemon
    detached from the calling code and never returns. The callbacks are issued
    before becoming a daemon. Multiple calls may be issued to reporter_func()
    if a timing has to be stopped before starting <name_to_start>.
    '''

    with self.lock:
      state = Tim.State()

    if state.started:
      if state.name == name_to_start:
        if reporter_func:
          reporter_func(Tim.ALREADY_RUNNNG, name_to_start)
        return True
      stopped_state = self.stop()
      if stopped_state and reporter_func:
        reporter_func(Tim.STOPPED, stopped_state.name)

    if reporter_func:
      reporter_func(Tim.STARTED, name_to_start)

    daemon_out = open('daemon.log', 'a+')
    with daemon.DaemonContext(
             stdout=daemon_out, stderr=daemon_out,
           ):
      try:
        my_pid = os.getpid()

        original_starting_time = str2time( time2str( now() ) )

        state = Tim.State(read=False)
        state.name = name_to_start
        state.started = original_starting_time
        state.minutes = 0
        state.minutes += 1  # <-- debug
        state.pid = my_pid
        with self.lock:
          state.save()

        while True:
          # try to run just after the break of the minute
          time.sleep(Tim.seconds_per_minute + 1
                     - (now() % Tim.seconds_per_minute))

          with self.lock:
            # verify that the state still shows the same starting time that
            # I was called to act on.
            state.read()
            if state.started:
              self.handle_stale_state(state)
            if not (state.pid == my_pid
                    and state.started == original_starting_time
                    and state.name == name_to_start):
              # the current state no longer concerns me.
              return

            # all is well, update the state
            state.minutes = ((int(now()) - state.started) 
                             / Tim.seconds_per_minute)
            print state.minutes
            state.save()
      finally:
        msg('daemon done')

  def get_log(self, start_date=None, end_date=None):
    year = self.timelog.year( time2year(now()) )
    year.read()
    return year


# invocation via commandline #################################################

class TimCmdline:
  def __init__(self, args):
    self.tim = Tim()
    self.args = args

    if any([(arg in args)
            for arg in ('-h', '--help', '-?', '-help', 'help')]):
      self.usage()

    if not args:
      # when called without arguments show status
      function = self.cmd_status
    else:
      cmd = args[0]
      func_name = 'cmd_' + cmd

      function = None
      if hasattr(self, func_name):
        function = getattr(self, func_name)
      if not callable(function):
        # convenience: omit 'start' for known project names
        if len(args) == 1:
          return self.cmd_start(*args)
        err("Unknown command: '", cmd, "'\ntry: 'tim help'")

    return function(*(args[1:]))

  def usage(self, error_message=None):
    msg(__doc__)
    if (error_message):
      errmsg(error_message)
      exit(1)
    exit(0)

  def cmd_new(self, *args):
    if len(args) > 1:
      err("'new' takes only one argument: an unknown name.")
    self.tim.new(args[0])

  def reporter(self, key, name):
    if key == Tim.ALREADY_RUNNNG:
      warn('Already running: ', name)
    elif key == Tim.STOPPED:
      msg('Stopped ', name)
    elif key == Tim.STARTED:
      msg('Started ', name)

  def cmd_start(self, *args):
    if len(args) > 1:
      err("'start' takes only one argument: a name.")
    name = self.tim.find_full_name(args[0])
    if not name:
      err("Unknown name: '", args[0], "' -- ",
          "try 'tim new ", args[0], "' first?")
    self.tim.start(name, self.reporter)

  def cmd_stop(self, *args):
    comment = ' '.join(args)
    stopped_state = self.tim.stop(comment)
    # notification
    if not stopped_state:
      err('No timer is running.')
    if stopped_state.comment:
      c = ' ' + stopped_state.comment
    else:
      c = ''
    msg('Stopped ', stopped_state.name,
        ' (', mins2str(stopped_state.minutes), ')', c)

  def cmd_status(self, *args):
    if args:
      err("'status' takes no arguments")
    status = self.tim.get_status()
    if status.started:
      msg('Running: ', status.name, '=', mins2str(status.minutes), ' (since ',
          time2str(status.started), ')')
    else:
      msg('Not running.')

  def cmd_totals(self, *args):
    selected = None
    if args:
      selected = [self.tim.find_full_name(arg) for arg in args]
    totals = self.tim.timelog.get_totals()
    if totals:
      msg('Totals:')
      def show(name, val):
        mins_str = mins2str(val)
        if not ':' in mins_str:
          mins_str = '%6s   ' % mins_str
        else:
          mins_str = '%9s' % mins_str
        msg(mins_str, ' ', name)
      grand_total = 0
      for name, val in sorted(totals.iteritems()):
        if (not selected) or (name in selected):
          grand_total += val
          show(name, val)
      msg('=========')
      show('all', grand_total)
    else:
      msg('Nothing is recorded.')

  def cmd_log(self, *args):
    if args:
      err("'log' takes no arguments")

    log = self.tim.get_log()
    for entry in log.entries:
      msg(str(entry))

if __name__ == "__main__":
  # run commandline client.

  try:
    TimCmdline(sys.argv[1:])
  except Error, e:
    errmsg(str(e))
    print
    raise #exit(-1)

