#!/usr/bin/env python
# coding: utf8
#
# Tim
# ===
# 
# project timer (GUI + cmdline)
# 
# You enter project names and start and stop them.
# Tim will keep track of how much you worked (and when) and how many of these
# worked hours you have already submitted to your money supplier.
# 
# (c) Copyright 2013 by Neels Janosch Hofmeyr <neels@hofmeyr.de> (GPLv3)
# 
# This file is part of Tim project timer.
# 
# Tim project timer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tim project timer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tim project timer.  If not, see <http://www.gnu.org/licenses/>.

r'''Tim project timer.

You enter names and start and stop them. Tim tracks how much you worked on
which (and when) and, if you like, how many of these worked hours you have
already submitted to your money supplier.

Make backups of your ~/.tim folder. It contains all of your time logs.

launch a systray icon and GUI:
  tim systray

command line usage:
  tim [status]
  tim new <project-name>
  tim [start] <project-name>
  tim start <project-name> [<comment>]
  tim [adjust] [@<started-time>|+<duration>|-<duration>|=<duration>]
  tim stop [<comment>]
  tim stopped [-]<HH:MM> [<comment>]
  tim totals [-l <name>[.*][,...]] [-g] \
             [round [<nr>] [hours|days|weeks|months|years]]
  tim log [<nr>] [hours|days|weeks|months|years] \
          [from|until|before|after <date>] \
          [sum [<nr>] hours|days|weeks|months|years] \
          [round [<nr>] [hours|days|weeks|months|years]] \
          [-l <name>[.*][,...]] [-g]
  tim tickoff <hours> [<project-name>] 
  tim tickoff --undo
  tim rename <current-project-name> <new-project-name>
  tim fix [<start-year>] [--clear]
  tim forget <project-name>
  tim remember [<id>] [--as <project-name>] [--add-to <project-name>]


--- tim systray ---
Launch a systray icon. Tim should appear in your window manager's taskbar. Put
'tim systray' in your window manager's autostart. If you click the systray
icon, you can interact with Tim using your mouse ... if you're like that.

--- tim status ---
Calling tim without arguments shows the current timer, if any is running. This
is the same as calling 'tim status'.

--- tim new ---
Announce a new project name. You can use dots '.' to create subgroups of
projects.
  tim new foo
  tim new yoyodyne.abc

--- tim start ---
When you start working on a given project, call 'tim start my_name'. The word
'start' can be omitted. Before you can start a name, you must tell Tim about
it with the 'tim new' command, just once for each name you want to use.

Project names can be grouped, simply by inserting dots in the name. Any number
of grouping levels is allowed. Any group name can still record timings, even
if it contains other names. Anything that makes sense to you... ;)

As soon as the project name is known with
  tim new my_group.my_name
you only need to type the part after the last dot, like
  tim my_name
Tim will find 'my_group.my_name' from that, as long as there is no other
'my_name' around in other groups.

You can supply a comment to go with the timing being started. If you do so,
just write the comment after the name to start. You may not omit the word
'start' when supplying a comment.
  tim start my_name My comment goes everywhere after the name.

The comment will be saved in the log, and it may be used to submit the timing
elsewhere. For example, the OpenGroupware export submits the comment to your
OpenGroupware server.

--- tim started ---
Say, I have been working since 9 AM, but I forgot to start the timer then. No
timer has been running, but it should have. I can correct that by calling
  tim started my_name 9:00
This is a shortcut for 'tim start my_name' followed by 'tim adjust @9'.

If a timer is already running, you must use 'tim adjust' instead. In above
example, if my_name is already running, simply say
  tim adjust @9
which is equivalent to
  tim @9

--- tim adjust ---
When a timer is currently running, adjust the recorded time. This always
shifts the started-time so that the desired duration results when counting up
to the current moment in time. The word 'adjust' may be omitted.

  @<started-time>
    I have actually started working on this project at <started-time>.
    Adjust the timing counter for the current project accordingly.
    <started-time> format is 'HH:MM', e.g. '14:59'. Wraps past midnight
    (yesterday's time is used when today's time would be in the future).
      tim @9      # make as if I called 'start' at 9 o'clock this morning
      tim @15:30  # "just joking, in fact I started at half past three."

  +<duration>
    Add <duration> to the currently running timer, make as if I started
    earlier.
    <duration>: [HH][:MM], for example:
      tim +1      # add one hour
      tim +1:30   # add one and a half hours
      tim +1.5    # add one and a half hours (decimal dot)
      tim +:30    # add thirty minutes

  -<duration>
    Subtract <duration>. '-10' is the same as '+-10'. Make as if I started
    later. This won't go below zero.

  =<duration>
    Set the current counter to exactly <duration> hours.
      tim =1      # make as if I called 'start' one hour ago

See also: 'stopped'.

--- tim stop ---
Stop the currently running timer. Any arguments after the word 'stop' are
stored as a comment for the hours just worked.

--- tim stopped ---
Say, I stopped working at half past three, but I forgot to stop the timer, and
it has been running in vain all afternoon. I can correct that by stopping the
timer with the 'stopped' command:
  tim stopped 15:30
This command goes back to half past three and stops the timer. The logs will
show that I stopped working at the time I really stopped working.

If you pass a negative time, 'stopped' subtracts hours from the current time.
If you forgot to stop the timer two and a quarter hours ago, simply call:
  tim stopped -2:15

Another way would be to subtract the surplus hours and stop then.
  tim adjust -2:15
  tim stop
This corrects the duration recorded in the logs, but it moves the starting
time forward by two hours fifteen minutes. If you want your logs to show
exactly at what times you started and stopped working, rather use the
'stopped' command, as it preserves the starting time and adjusts the stopping
time instead.

See also: 'adjust', to change the starting time.

--- tim totals ---
Print the current timing totals of hours spent vs. hours ticked-off on a
per-group and per-project basis.

This adds timings of all names in a group up to the group's own total. So if
you have employer 'yoyo' and projects 'foo' and 'bar', you will start and stop
timings on 'yoyo.foo' and 'yoyo.bar'. They get positive totals. When you
submit worked hours to Yoyo, you can tick off on 'yoyo' instead of the
specific projects. The timings for 'yoyo' become negative. But in the totals,
'foo' and 'bar' are added to its parent 'yoyo', so that 'yoyo' reaches zero
when all worked hours have been ticked off.

  -l <name>[,<name>[,...]]
    Limit the listing to the given names.

  -g
    Show per-group timings, do not add them up to the parent groups. Like this
    you may see ticked off hours as negative timings.

--- tim log ---
Show the timings for this week ('1 week' is the default).

This also shows a sum of the timings that are selected.

Selecting a time period is done in rough english. Examples:
  tim log 2 weeks
  tim log 1 month                  # starts at the beginning of this month
  tim log 1 month before now       # starts ~30 days ago
  tim log 1 week after 2012-08-31
  tim log 3 months before 2013-01
The words can be abbreviated down to their starting letters, and the default
amount is 1. These commands are equivalent to those above:
  tim log 2 w
  tim log mon
  tim log m b n
  tim log w a 2012-08-31
  tim log 3 m b 2013
Available tokens:
  days weeks months years -- you get what you see.
  from <date>   -- take the given date as starting point, including <date>.
  until <date>  -- take the given date as end point, including <date>.
  after <date>  -- like 'from', but EXCLUDING <date>.
  before <date> -- like 'until', but EXCLUDING <date>.

A <date> is of the format 'YYYY-MM-DD_hh:mm', where parts of it may be
omitted. If <date> starts with a dash, the current year and month are
inserted as necessary:
  YYYY-MM-DD_hh:mm
  YYYY-MM-DD
  YYYY-MM
  YYYY
  -DD
  -MM-DD
Examples:
 '2013-01-11' = 00:00 on 11th of January, 2013.
 '2013-01-11_23:45' = 23:45 on 11th of January, 2013.
 '-10' = 10th of this month, 0:00 AM.
 '-1-1' = first of January, this year.
 '2013' = new year's 2013, 0:00 AM.

By default, log shows every single timing. You can add up timings within a
given time period with a 'sum' argument:
  tim log sum days
This shows the log for this week, but only each day's total, with a list of
names involved on that day. 'sum' can also be abbreviated down to 's'.
'sum' also takes numbers and the 'full' argument:
  tim log 1 year sum 3 months
adds up each quartal of the year.
  tim log sum full days
shows this week's timings starting on monday, and takes the current time as
the end-of-a-day boundary (may be useful if you work around midnight and don't
want those timings to be divided between two calendar days).
  
    default: show each timing in hours and minutes
    -D/-W/-M/-Y  start at the beginning of this day/week/month/year
    -f  start one full time period ago, flowing, floating past boundaries.
        For example, '-f -W' starts seven days ago, instead of last monday;
        '-f -M' starts the same day last month, instead of this month's 1st.
    -n <nr>
       Repeat above time period for <nr> times into the past.
  -s <date>

Options:
  -l <name>
    Limit the listing to this project (or group).

  -s
    Show per-group timings, do not add them up to the parent groups. Like this
    you may see ticked off hours as negative timings.

  -d/-w/-m/-y
    combine hours for each day/week/month/year

--- tim tickoff ---
Record hours that you have already billed your money supplier for. If you are
timing private / hobby projects, your total hours will simply grow. But if you
have an employer, ticking off is useful to keep track of how many hours you
have actually passed on to your employer's accounting. If you are using
tickoff for any given project, you probably want to reach a total of zero for
that project at regular intervals. If you've worked less than you billed, your
total hours become negative.
- If no project name is supplied, the tickoff is chronologically spread across
  all projects, so that the hours worked longest ago are ticked off first.
    tim tickoff 32
- You can tickoff a group (yoyodyne), in which case the hours contained in any
  sub-projects and sub-sub-projects are ticked-off in their chronological
  order (see examples below). You can also tickoff subprojects specifically.
    tim tickoff 32 yoyodyne
- If a group's total is negative, I've already billed hours I haven't worked
  yet; over time, sub-projects of such a group will receive new hours, but the
  negative total of the parent will only be neutralised at the next tickoff
  command. You may call 'tim tickoff 0 my_name' to chronologically
  neutralise a negative total with hours worked in sub-projects.
- If you want to keep strictly separate project groups, you should take
  care to never call 'tickoff' without a name argument, or hours will be
  neutralised on the root level of all groups. If that should go wrong one
  day, you can undo tickoffs one by one with:
    tim tickoff --undo

--- tim rename ---
Rename a project while keeping its hours and logs. This may also move projects
around between groups.
Note that this changes the name in all logs back to the start of time, so the
'tim log' command will not look the same as before.

--- tim fix ---
Run through the logs, summing up everything, to verify and correct the grand
total shown by 'tim totals', and to verify and correct the initial totals at
the beginning of each log file.
This is particularly useful to edit the recorded timings: simply edit the log
files in ~/.tim/timelog/, then call 'tim fix' to carry the edits through to
following log files and the current grand total.
Without arguments, all available years are checked and corrected. Each year's
final totals are carried over to the next year's initial totals. You can ask
tim to start at a given year if you don't want to run through all of them.
This will *always* run all the way to the present, and will finally adjust the
current grand totals on record if necessary (those shown by 'tim totals').
You can provide the option '--clear' to erase the initial totals of the
starting year. When calling 'tim fix --clear', the first log on record will
have its initial totals reset to zero.
  tim fix
  tim fix 2012  # starts with 2012 and ends with the latest log on record

--- tim forget ---
Remove a given project from accounting. The data will still be sitting in the
database, but it will appear to be completely removed with all its history
when interacting with tim.

--- tim remember ---
Recover a project previously forgotten with 'tim forget'. Run without
arguments to get a listing of IDs for forgotten projects or groups.

--- EXAMPLE ---
  This example shows a sequence of tim commands. Imagine that time passes
  between each pair of start ... stop commands.
  
  tim new foo
  tim foo
  tim stop
  tim foo
  tim stop

  tim new yoyodyne.abc     # announce project abc in group yoyodyne
  tim yoyodyne.abc         # start timing for project abc in the group yoyodyne
  tim +1                   # fake starting-time so that I've worked 1 hour now
  tim stop "fix a bug"     # stop timing, record in the log with a message
  tim abc                  # start yoyodyne.abc; tim finds 'abc' in 'yoyodyne'.
  tim stop
  tim new yoyodyne.xyz.bar # announce project bar in new group yoyodyne.xyz
  tim xyz                  # start yoyodyne.xyz (yes, "groups" can also start)
  tim abc                  # stop yoyodyne.xyz, start yoyodyne.abc, in one go
  tim stop

  tim log                  # show the log of this week (starting monday)
  tim log -w -n 5          # show last five weeks (five times seven days)
  tim log yoyodyne         # show log for yoyodyne.* projects only

  tim totals               # show the sum of all hours for all projects
  tim tickoff 32 yoyodyne  # I have billed yoyodyne for 32 hours.
  tim totals               # Above 32 hours are now subtracted from the totals.
 '''

import re, os, errno, time, shutil, sys, signal
import daemon
import lockfile
from os.path import join as j
from time import time as now


# messaging and error handling ###############################################

def msgs2str(msgs):
  return ''.join([str(m) for m in msgs])

class Error(Exception):
  def __init__(self, *msgs):
    self.msg = msgs2str(msgs)
  def __str__(self):
    return self.__class__.__name__ + ': ' + self.msg

def _raise(*msgs):
  raise Error(*msgs)

def _warn(*msgs):
  print '***', msgs2str(msgs)

def _msg(*msgs):
  print msgs2str(msgs)

def _errmsg(*msgs):
  sys.stderr.write('tim: ')
  for msg in msgs:
    sys.stderr.write(msg)
  sys.stderr.write('\n')
  sys.stderr.flush()
  

# generic conversion functions ###############################################

def mins2str(float_mins):
  sign = 1
  frac = 59.0
  if float_mins < 0:
    float_mins = -float_mins
    sign = -1
    frac = 1.0
  
  minutes = int(float_mins)
  if float_mins - float(minutes) > (frac/60):
    minutes += 1

  h, m = divmod(minutes, 60)

  if m == 0:
    return str(sign * h)
  elif sign < 0:
    # just 'h *= sign' won't work if h == 0.
    return "-%d:%02d" % (h,m)
  else:
    return "%d:%02d" % (h,m)

class FormatError(Error):
  pass

def str2mins(str_hours):
  try: 
    if str_hours.find(':') < 0:
      return int(round(float(str_hours) * 60.0))

    h, m = str_hours.split(':')
    sign = 1
    if h.startswith('+'):
      h = h[1:]
    if h.startswith('-'):
      h = h[1:]
      sign = -1

    if not h or len(h) < 1:
      fh = 0
    else:
      fh = float(h)

    if not m or len(m) < 1:
      fm = 0
    else:
      fm = float(m)

    return int(sign * round(fh * 60.0 + fm))
  except Exception, e:
    raise FormatError("Not a time string: '", str_hours, "'")

TIMESTR_FORMAT = "%Y-%m-%d %H:%M"
FILENAME_TIMESTAMP_FORMAT = "%Y_%m_%d_%H_%M_%S"

def time2str(float_time, fmt=TIMESTR_FORMAT):
  if not float_time:
    return None
  return time.strftime(fmt, time.localtime(float(float_time)))

def str2time(string, fmt=TIMESTR_FORMAT):
  if not string or len(string) < 1:
    return None
  return time.mktime( time.strptime(string, fmt) )

def time2year(float_time):
  return int(time.strftime('%Y', time.localtime(float_time)))

def filename_timestamp(float_time=None):
  if float_time is None:
    float_time = float(time.time())
  return time.strftime(FILENAME_TIMESTAMP_FORMAT,
                       time.localtime(float(float_time)))

UNIT_HOUR = 0
UNIT_DAY = 1
UNIT_WEEK = 2
UNIT_MONTH = 3
UNIT_YEAR = 4

def date_beginning_of(unit, date):
  if UNIT_HOUR == unit:
    round_fmt = "%Y %j %H"
  elif UNIT_DAY == unit:
    round_fmt = "%Y %j"
  elif UNIT_WEEK == unit:
    round_fmt = "%Y %W"
  elif UNIT_MONTH == unit:
    round_fmt = "%Y %m"
  elif UNIT_YEAR == unit:
    round_fmt = "%Y"
  return str2time( time2str(date, fmt=round_fmt), fmt=round_fmt)
  
def date_end_of(unit, date):
  return date_beginning_of(unit,
                           date_beginning_of(unit, date)
                             + 1.5 * date_seconds_per(unit))
  
def date_add(amount, unit, date):
  amount_frac, amount_int = math.modf(amount)
  amount_int = int(amount_int)
  seconds_per_unit = date_seconds_per(unit)
  # integer part
  if int_amount:
    beginning = date_beginning_of(unit, date)
    surplus = date - beginning
    mid = beginning + seconds_per_unit/2
    mid += seconds_per_unit * amount
    result = date_beginning_of(unit, mid) + surplus
  else:
    result = date
  # fractional part
  result += amount_frac * seconds_per_unit
  return result

def date_subtract(amount, unit, date):
  return date_add(-amount, unit, date)

def date_seconds_per(unit):
  if UNIT_HOUR == unit:
    return 60.*60
  elif UNIT_DAY == unit:
    return 60.*60*24
  elif UNIT_WEEK == unit:
    return 60.*60*24*7
  elif UNIT_MONTH == unit:
    return 60.*60*24*(365.25/12)
  elif UNIT_YEAR == unit:
    return 60.*60*24*365.25

# os file & process functions ################################################

def write_file(path, contents, mkdirs=True):
  if mkdirs:
    dirname = os.path.dirname(path)
    if not os.path.exists(dirname):
      os.makedirs(dirname)
  f = open(path, "w")
  f.write(contents)
  f.close()

def append_to_file(path, *contents):
  f = open(path, "a")
  for c in contents:
    f.write(c)
  f.close()

def read_file(path):
  try:
    f = open(path, "r")
    contents = f.read()
    f.close()
    return contents
  except IOError:
    return None

def read_file_lines(path):
  try:
    f = open(path, "r")
    contents = f.readlines()
    f.close()
    return contents
  except IOError:
    return None

def process_is_running(pid):
  try:
    os.kill(int(pid), 0)
    return True
  except OSError as e:
    if e.errno == errno.ESRCH: # no such process
      return False
    raise

def gently_kill_process(pid):
  if not (pid and process_is_running(pid)):
    return True
  _msg('kill -SIGINT ', pid)
  os.kill(pid, signal.SIGINT)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  _msg('kill -SIGTERM ', pid)
  os.kill(pid, signal.SIGTERM)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  _msg('kill -SIGKILL ', pid)
  os.kill(pid, signal.SIGKILL)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  return False
 

# strings and regexes ########################################################

INITIAL_TOTAL_KEYWORD = 'init:'
NAME_RE = '([a-zA-Z_][a-zA-Z0-9_]*\.)*[a-zA-Z_][a-zA-Z0-9_]*'
NAMES_RE = '(' + NAME_RE + ')(,' + NAME_RE + ')*'
NAME_STR_RE = '\A' + NAME_RE + '\Z'
NAMES_STR_RE = '\A' + NAMES_RE + '\Z'
TIME_RE = '[+-]{0,1}[0-9:]+'
DATE_RE = r'(\d{1,4})-(\d{1,2})-(\d{1,2})[_ ](\d{1,2})[-:](\d{1,2})'
TOTAL_RE = '(' + NAME_RE + ')=(' + TIME_RE + ')'
TOTALS_LINE_RE = '^' + TOTAL_RE + '$'
LOG_INITIAL_TOTAL_RE = '^' + INITIAL_TOTAL_KEYWORD + ' *(.*) *$'
TIMING_RE = '^' + DATE_RE + '[: ]+([^ ]+) (' + TIME_RE + ')($| *# {0,1}(.*)$)'
STATE_RE = '^([0-9]+) (.*)$' # a PID, and a log entry (parsed in second step)

name_syntax_docstr = (
'''A name may only contain letters a-z, A-Z, decimal numbers and the underscore _;
A name may not start with a number. Names can be arranged in groups, by using
a dot to separate group levels: 'tim new my_group.my_inner_group.my_name'.''')

class Regex:
  '''Caches compiled regular expressions. A call to
  Regex.match('([a-z]*) ([0-9]*)', 'foo 123') returns a re.match object and
  compiles that regex only once, no matter how often match() is called.'''
  cache = {}
  @staticmethod
  def compiled(regex):
    compiled = Regex.cache.get(regex)
    if not compiled:
      compiled = re.compile(regex)
      Regex.cache[regex] = compiled
    return compiled
  @staticmethod
  def match(regex, string):
    return Regex.compiled(regex).match(string)
    

# classes implementing Tim ###################################################

class Notify(object):
  def __init__(self, notify_func):
    ''' notify_func(key, arg): function that notifies the user; the
    calling code can/should show these messages to the user in some way.

    key: One of the Notify.CONSTANTs
    
    arg: depends on the key...

      Notify.STARTED,
      Notify.ALREADY_RUNNING:
        arg: the name of the project that was successfully started / stopped
              / was not started since the same name is already running.

      Notify.STOPPED,
        arg: a State instance reflecting the state that has just been stopped
             and recorded in the time log.

      Notify.STALE:
        arg: (state, reason)
             state: a State instance like with Notify.STOPPED.
             reason: a short string meaning
               reason == State.REASON_STALE:
                 The state was last updated too long ago, i.e.  state.started
                 and state.minutes don't add up to the current time.
               reason == State.REASON_DAEMON_EXITED:
                 There is no process with PID == state.pid, so the daemon
                 updating the state has exited.
             A stale state is a running state that has not been updated for a
             long time, maybe because the machine was suspended or crashed.
             The timing was saved to the time log, only counting the time that
             the state was being updated (state.timing.minutes).

      Notify.MSG,
      Notify.WARN,
      Notify.ERROR:
        arg: a message to display.
    '''
    self.notify_func = notify_func

  def msg(self, *msgs):
    if self.notify_func:
      self.notify_func(Notify.MSG, msgs2str(msgs))

  def warn(self, *msgs):
    if self.notify_func:
      self.notify_func(Notify.WARN, msgs2str(msgs))

  def err(self, *msgs):
    if self.notify_func:
      self.notify_func(Notify.ERROR, msgs2str(msgs))

  ALREADY_RUNNING = 0
  STARTED = 1
  STOPPED = 2
  STALE = 3
  MSG = 4
  WARN = 5
  ERROR = 6



class Timing:
  def __init__(self, **kwargs):
    self.set_values(**kwargs)
  
  def set_values(self, started=None, name=None, minutes=None, comment=None):
    if name:
      Timelog.validate_name(name)
    self.started = started
    self.name = name
    self.minutes = minutes
    self.comment = comment
    if not self.comment:
      self.comment = None
    return self

  def clear(self):
    self.set_values()

  def started_str(self):
    return time2str(self.started)

  def serialize(self):
    return repr(self) + '\n'

  def __str__(self):
    return repr(self)

  def __repr__(self):
    if self.started:
      started_str = self.started_str()
    else:
      started_str = 'not_started'
    elts = [started_str,
            self.name or 'unnamed',
            mins2str(self.minutes or 0)]
    if self.comment:
      elts.append('#')
      elts.append(self.comment)
    return ' '.join(elts)

  def deserialize(self, line):
    match = Regex.match(TIMING_RE, line)
    if not match:
      return None
    else:
      self.set_values(
                    started=str2time('%s-%s-%s %s:%s' % match.groups()[0:5]),
                    name=match.group(6),
                    minutes=str2mins(match.group(7)),
                    comment=match.group(9),
                   )
      return self

  def add_comment(self, comment):
    'Append to current comment. Return True iff self.comment changed.'
    if comment:
      was = self.comment
      self.comment = (self.comment or '') + comment
      if was != self.comment:
        return True
    return False


class State:
  STOPPED = 'stopped'

  def __init__(self, state_file_path, read=True):
    self.timing = Timing()
    self.pid = None
    self.state_file_path = state_file_path
    if self.state_file_path and read:
      self.read()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    if self.timing.started:
      return str(self.pid) + ' ' + self.timing.serialize()
    else:
      return State.STOPPED

  def set_values(self, pid=None, **kwargs):
    self.pid = pid
    return self.timing.set_values(**kwargs)

  def serialize(self):
    return repr(self) + '\n'

  def deserialize(self, string):
    match = Regex.match(STATE_RE, string)
    if not match:
      return False
    # State only adds the pid field to Timing, so
    # STATE_RE only adds a pid nr to TIMING_RE
    self.pid = int(match.group(1))
    self.timing.deserialize(match.group(2))
    return True

  def save(self):
    "write this state to file"
    write_file(self.state_file_path, self.serialize())
    return self

  def clear(self):
    self.pid = None
    self.timing.clear()

  def read(self):
    self.clear()

    if not os.path.isfile(self.state_file_path):
      return False

    statestr = read_file(self.state_file_path)
    if statestr is None:
      return True # stopped. no data.
    statestr = statestr.strip()
    if statestr == State.STOPPED:
      return True # stopped. no data.

    return self.deserialize(statestr)

  REASON_STALE = 'stale'
  REASON_DAEMON_EXITED = 'daemon exited'

  def is_stale(self):
    assert(self.timing.started)
    expected_now = (self.timing.started 
                    + (self.timing.minutes * Tim.seconds_per_minute))
    timestep = now() - expected_now
    if timestep > Tim.stale_threshold:
      return State.REASON_STALE
    if not process_is_running(self.pid):
      return State.REASON_DAEMON_EXITED
    return None


class Totals:
  def __init__(self, totals_path=None, read=True):
    self.entries = {}
    self.totals_path = totals_path
    if totals_path and read:
      self.read()

  def set_to(self, other_totals_instance):
    self.entries = other_totals_instance.entries.copy()
    return self

  def copy(self):
    return Totals().set_to(self)

#  def add_all(self, other_totals_instance):
#    for name, minutes in other_totals_instance.iteritems():
#      self._add_timing(name, minutes)

  class TotalsErr(Error):
    pass

  def add_name(self, name):
    if name in self.entries:
      raise Totals.TotalsErr("Already exists: '", name, "'")
    self.entries[name] = 0

  def _add_timing(self, name, minutes):
    self.entries[name] = (self.get(name) or 0) + minutes

  def add_timing(self, timing):
    self._add_timing(timing.name, timing.minutes)

  def get(self, *args):
    return self.entries.get(*args)

  def iteritems(self):
    return self.entries.iteritems()

  def __iter__(self, *args):
    return self.entries.__iter__(*args)

  def __eq__(self, other):
    return self.entries.__eq__(other.entries)
  def __ne__(self, other):
    return self.entries.__ne__(other.entries)

  def is_empty(self, selected=None):
    if not selected:
      return not self.entries
    return not [item for item in self.entries if item in selected]

  def deserialize(self, line):
    match = Regex.match(TOTALS_LINE_RE, line)
    if not match:
      raise Totals.TotalsErr('Line does not match "' + TOTALS_LINE_RE + '"')
    name = match.group(1)
    Timelog.validate_name(name)
    minutes = str2mins(match.group(3))
    if name in self.entries:
      raise Totals.TotalsErr('Duplicate name: ' + name)
    self.entries[name] = minutes

  def read(self):
    lines = read_file_lines(self.totals_path)
    self.entries = {}
    if lines:
      line_nr = 0
      for line in lines:
        line_nr += 1
        if not line.strip():
          continue
        self.deserialize(line)

  def get_serialized_items(self):
    return [ ( '%s=%s\n' % (name, mins2str(minutes)) )
            for name, minutes in sorted(self.iteritems())]

  def __repr__(self):
    return ''.join(self.get_serialized_items())

  def save(self):
    assert(self.totals_path)
    write_file(self.totals_path, repr(self))

  def clear(self):
    self.entries = {}

  def to_string(self, selected=None):
    items = []
    seen = set()

    for name, minutes in self.iteritems():
      if (not selected) or (name in selected):
        items.append((name, minutes))
        seen.add(name)
    
    if selected:
      for name in selected:
        if not name in seen:
          items.append((name, 0))
          seen.add(name)

    def tostr(name, minutes):
      mins_str = mins2str(minutes)
      if not ':' in mins_str:
        mins_str = '%6s   ' % mins_str
      else:
        mins_str = '%9s' % mins_str
      return msgs2str((mins_str, ' ', name))

    out = []
    grand_total = 0
    for name, minutes in sorted(items):
      grand_total += minutes
      out.append(tostr(name, minutes))

    out.append('    =====')
    out.append(tostr('', grand_total))
    return '\n'.join(out)

  def __str__(self):
    return self.to_string(None)

  def find_full_names(self, name):
    with_children = False
    only_children = False
    if name.endswith('*'):
      name = name[:-1]
      with_children = True
      if name.endswith('.'):
        name = name[:-1]
        only_children = True
        
    Timelog.validate_name(name)

    matches = set()
    if (not only_children) and (name in self.entries):
      matches.add(name)

    for known_name in self.entries:
      tokens = known_name.split('.')
      while tokens:
        if name == tokens[-1]:
          matches.add('.'.join(tokens))
        del tokens[-1]

    if with_children:
      children = set()
      for name in matches:
        children.update(self.find_all_children(name))

      if only_children:
        matches = children
      else:
        matches.update(children)

    return matches

  def find_full_name(self, name):
    matches = self.find_full_names(name)
    if name in matches:
      return name
    if len(matches) > 1:
      raise Totals.TotalsErr("Multiple matches found for '", name, "':\n",
             '\n'.join([('- ' + m) for m in sorted(matches)]))
    elif len(matches) == 1:
      return matches.pop()
    else:
      return None

  def find_all_children(self, name):
    Timelog.validate_name(name)
    children = []
    for known_name in self.entries:
      if known_name.startswith(name) and known_name != name:
        children.append(known_name)
    return children




class Timelog(Notify):

  def __init__(self, notify_func, timelog_dir):
    Notify.__init__(self, notify_func)
    self.timelog_dir = timelog_dir
    self.totals_path = j(self.timelog_dir, 'totals')
    self.clear()

  def clear(self):
    self.timelog_files = {}

  class InvalidNameError(Error):
    pass

  @staticmethod
  def validate_name(name, allow_multiple_names=False):
    if allow_multiple_names:
      regex = NAMES_STR_RE
    else:
      regex = NAME_STR_RE
    if not Regex.match(regex, name):
      raise Timelog.InvalidNameError(
               "Invalid name: '", name, "'\n",
               name_syntax_docstr)

  def get_totals(self):
    return Totals(self.notify_func, self.totals_path)

  def add_name(self, name):
    Timelog.validate_name(name)
    t = self.get_totals()
    t.add_name(name)
    t.save()

  def add_timing(self, timing):
    timings_file = self.year()
    timings_file.add_timing(timing)
    t = self.get_totals()
    t.add_timing(timing)
    t.save()


  class TimingsFile(Notify):
    def __init__(self, notify_func, path, read=True):
      Notify.__init__(self, notify_func)
      self.path = path
      self.timings = None
      self.totals = None
      self.initial_totals = None
      self.exists = None
      if read:
        self.read()

    def read(self):
      self.exists = False
      try:
        lf = open(self.path, "r")
        self.exists = True
      except IOError as e:
        if e.errno == errno.ENOENT:
          self.timings = []
          self.initial_totals = Totals()
          self.totals = Totals()
          self.exists = False
          return
        raise

      try:
        self.timings = []
        self.initial_totals = Totals()

        line_nr = 0

        # read initial totals
        while True:
          at = lf.tell()
          line = lf.readline()
          line_nr += 1
          match = Regex.match(LOG_INITIAL_TOTAL_RE, line)
          if match:
            total_string = match.group(1)
            self.initial_totals.deserialize(total_string)
          else:
            # done with initial totals.
            # unread last line, continue below.
            lf.seek(at)
            line_nr -= 1
            break

        self.totals = self.initial_totals.copy()

        while True:
          line = lf.readline()
          line_nr += 1
          if not line:
            break

          t = Timing().deserialize(line)
          if not t:
            _raise('cannot parse line ', line_nr, ' in timelog file ', 
                   self.path)
          self.timings.append(t)

        self.update_totals()

      finally:
        lf.close()

    def update_totals(self):
      self.totals = Totals()
      self.totals.set_to(self.initial_totals)
      for t in self.timings:
        self.totals.add_timing(t)

    def add_timing(self, timing):
      assert(isinstance(timing, Timing))
      if timing.minutes == 0:
        return
      append_to_file(self.path, timing.serialize())
      self.timings.append(timing)
      self.update_totals()

    def save(self):
      lines = [ ' '.join((INITIAL_TOTAL_KEYWORD, line))
                for line in self.initial_totals.get_serialized_items() ]
      lines.extend([ t.serialize() for t in self.timings ])
      write_file(self.path, ''.join(lines))

  def path_for_year(self, year):
    return j(self.timelog_dir, str(int(year)))

  @staticmethod
  def current_year():
    return time2year(now())

  def year(self, year=None):
    if year is None:
      year = Timelog.current_year()
    year = int(year)
    timings_file = self.timelog_files.get(year)
    if not timings_file:
      timings_file = Timelog.TimingsFile(self.notify_func,
                                         self.path_for_year(year))
      self.timelog_files[year] = timings_file
      timings_file.read()
    return timings_file
    
  def years_available(self):
    files = os.listdir(self.timelog_dir)
    return [int(name) for name in files
            if name.isdigit() and os.path.isfile(j(self.timelog_dir, name))]

  def fix(self, start_year=None, clear=False):
    unfixed = 0
    fixes_made = 0

    if start_year:
      start_year = int(start_year)

    def diff_totals(t_is, t_shouldbe):
      for name, minutes in sorted(t_is.iteritems()):
        shouldbe_minutes = t_shouldbe.get(name)
        if shouldbe_minutes != minutes:
          if shouldbe_minutes is None:
            shouldbe_str = ', but there is no prior record of that name.'
          else:
            shouldbe_str = ', should be ' + mins2str(shouldbe_minutes)
          self.msg(' - ', name, ' is ', mins2str(minutes), shouldbe_str)
      for name,minutes in sorted(t_shouldbe.iteritems()):
        if not name in t_is:
          self.msg(' - ', name, ' is missing, should be ', mins2str(minutes))

    prev_totals = None

    years_available = self.years_available()
    years_available = range(min(years_available), max(years_available)+1)

    if not start_year:
      start_year = years_available[0]
    elif start_year not in years_available:
      _raise('No record for ', start_year)

    for yearnr in years_available:
      if yearnr < start_year:
        continue
      year = self.year(yearnr)
      if not year.exists:
        self.warn('No log for ', yearnr)

      changed_initial_totals = False

      if (not prev_totals) and (not year.initial_totals.is_empty()):
        if clear:
          save_path = j(os.path.dirname(year.path),
                        'initial_totals_of_' + os.path.basename(year.path)
                        + '_removed_at_' + filename_timestamp())
          self.msg('** clearing initial totals of ', yearnr, '\n',
                   '** saving to: ', save_path)
          write_file(save_path, repr(year.initial_totals))
          year.initial_totals.clear()
          changed_initial_totals = True
          fixes_made += 1
        elif yearnr == years_available[0]:
          unfixed += 1
          self.warn('NOT FIXING: ', yearnr, ' is the first year on record, ',
                    'but it has initial totals:\n',
                    '\n'.join([ ('*** ' + line) 
                                for line in
                                str(year.initial_totals).split('\n')]))
        else:
          self.msg('Starting off with initial totals of ', yearnr)
        
      elif prev_totals and (prev_totals != year.initial_totals):
        self.msg('** fixing: the initial totals in ', yearnr, ' are wrong.')
        diff_totals(year.initial_totals, prev_totals)

        year.initial_totals.set_to(prev_totals)
        changed_initial_totals = True
        fixes_made += 1

      if changed_initial_totals:
        year.update_totals()
        year.save()

      prev_totals = year.totals

    # finally, update the current grand totals to the last totals seen
    if prev_totals:
      totals = self.get_totals()
      if totals != prev_totals:
        self.msg('** fixing: the grand totals are wrong.')
        diff_totals(totals, prev_totals)
        totals.set_to(prev_totals)
        totals.save()
        fixes_made += 1

    if (fixes_made < 1) and (unfixed < 1):
      self.msg('All correct.')
    else:
      if fixes_made:
        self.msg('** errors fixed: ', fixes_made)
      if unfixed:
        self.warn('unfixed errors: ', unfixed)

  class QueryErr(Error):
    pass

  class QueryPhraseParser:
    unit_phrases = {
        'hours' : UNIT_HOUR,
        'days' : UNIT_DAY,
        'weeks' : UNIT_WEEK,
        'months' : UNIT_MONTH,
        'years' : UNIT_YEAR,
      }
    def __init__(self, tokens):
      self.tokens = tokens
      self.amount = None
      self.unit = None
      self.start = None
      self.end = None
      self.snap_to_calendar = None
      self.group = None
      self.rounding = None

      self.l = len(tokens)
      self.i = -1
      self.token = None

      self.parse()

    def next_arg(self):
      if (self.i + 1) >= self.l:
        return False
      self.i += 1
      self.token = self.tokens[self.i]
      return True

    def expect_arg(self, name):
      self.next_arg()
      if self.i >= self.l:
        self.err('Missing ', name, ' argument at end of arguments')

    def next_date_arg(self):
      self.next_arg('date')
      return self.parse_date_str(self.token)

    def unit_arg(self):
      for phrase, phrase_unit in Timelog.QueryPhraseParser.unit_phrases.iteritems():
        if phrase.startswith(self.token):
          return phrase_unit
      return None

    def nr_arg(self):
      try:
        minutes = str2mins(self.token)
      except FormatError:
        return None
      return float(minutes) / 60

    def superfluous(self, name, val):
      if val is not None:
        self.err('Superfluous ', name)

    def err(self, *msgs):
      raise QueryErr(msgs2str(msgs), " ('", self.token,
                     "', word ", self.i+1, ')')
      
    def parse(self):
      while self.next_arg():
        arg_unit = unit_arg()
        if arg_unit:
          self.superfluous('unit', self.unit)
          self.unit = arg_unit
        elif 'complete'.startswith(self.token):
          self.superfluous('complete keyword', self.snap_to_calendar)
          self.snap_to_calendar = False
        elif 'from'.startswith(self.token):
          self.superfluous('start indicator', self.start)
          self.start = self.next_date_arg(beginning=True)
        elif 'after'.startswith(self.token):
          self.superfluous('start indicator', self.start)
          self.start = self.next_date_arg(after=True)
        elif 'until'.startswith(self.token):
          self.superfluous('end indicator', self.end)
          self.end = self.next_date_arg(end=True)
        elif 'before'.startswith(self.token):
          self.superfluous('end indicator', self.end)
          self.end = self.next_date_arg(before=True)
        elif 'sum'.startswith(self.token):
          self.superfluous('sum request', self.sum_unit)
          self.next_arg()
          self.sum_unit = self.unit_arg()
          if not self.sum_unit:
            self.sum_amount = self.nr_arg()
            if self.sum_amount is None:
              self.err('Expecting number or time unit')
            self.next_arg()
            self.sum_unit = self.unit_arg()
            if self.sum_unit is None:
              self.err('Expecting time unit')
          else:
            self.sum_amount = 1
        elif 'round'.startswith(self.token):
          self.err('round not implemented')
        else:
          nr = self.nr_arg()
          if nr is not None:
            self.superfluous('number', self.amount)
            self.amount = nr
          else:
            self.err('Unknown argument')


  class Query:

    def __init__(self, unit=UNIT_WEEK, amount=1.0,
                 start=None, end=None, snap_to_calendar=True):
      '''unit: a UNIT_* constant.
         amount: a float number.
         start: a start date in unix time (seconds since epoch), inclusive.
         end: a date like in start, inclusive.
         snap_to_calendar: if True, amount is reduced to start with a
           beginning of the <unit> (week, month...).
      '''
      self.unit = unit
      self.amount = amount
      self.start = start
      self.end = end
      self.snap_to_calendar = snap_to_calendar


    def from_phrase(self, _tokens):
      parser = Timelog.QueryPhraseParser(tokens)
      self.start = parser.start
      self.end = parser.end
      self.unit = parser.unit or self.unit
      self.amount = parser.amount or self.amount
      self.snap_to_calendar = parser.snap_to_calendar or self.snap_to_calendar


  class Result:
    def __init__(self):
      self.timings = []
      self.totals = Totals()

    def add_timing(self, timing):
      self.timings.append(timing)
      self.totals.add_timing(timing)


  def run_query(self, query):
    '''query: a Timelog.Query instance describing the search request.
       returns: a Timelog.Result instance with .timings and .totals
                populated according to the query.'''
    if (query.start is None) and (query.end is None):
      end = now()
      start = None
      amount = query.amount
    else:
      start = query.start
      end = query.end
      amount = query.amount
    unit = query.unit

    if (start is not None) and (end is not None) and (amount is not None):
      raise QueryErr('One of start, end or amount must be None.')
    
    if end is None:
      if (amount is None) or (start is None):
        raise QueryErr('When there is no end, I need an amount and a start.')
      # rearrange into end with negative amount
      end = start
      amount = -amount

    if start is None:
      if (amount is None) or (end is None):
        raise QueryErr('When there is no start, I need an amount and an end.')

      if query.snap_to_calendar:
        if amount >= 1:
          end = date_end_of(unit, end)
          start = date_subtract(amount, unit, end)
        if amount <= -1:
          start = date_beginning_of(unit, end)
          end = date_add(amount, unit, start)
      else:
        start = date_subtract(amount, unit, end)
      
    elif amount is None:
      if (start is None) or (end is None):
        raise QueryErr('When there is no amount, I need a start and an end.')
      
    return self.get_entries(start, end)

  def get_entries(self, start_date, end_date):
    if start_date > end_date:
      x = start_date
      start_date = end_date
      end_date = x

    y = time2year(start_date)
    end_year = time2year(end_date)

    result = Timelog.Result()
    while y <= end_year:
      year = self.year(y)
      for timing in year.timings:
        if ((timing.started >= start_date)
            and (timing.started <= end_date)):
          result.add_timing(timing)
      y += 1

    return result







    


class TimedDirLock(Notify):
  id_count = 0

  def __init__(self, notify_func, lock_path,
               sleep_time_in_seconds=1.0, timeout=30, valid_for=10):
    Notify.__init__(self, notify_func)
    self.lock = self.__enter__
    self.unlock = self.__exit__
    self.lock_path = lock_path
    self.sleep_time_in_seconds = sleep_time_in_seconds
    self.timeout = timeout
    self.valid_for = valid_for
    self.acquired = None
    self.id_file = j(self.lock_path, 'pid')
    self.id = TimedDirLock.id_count
    TimedDirLock.id_count += 1
    self.lock_count = 0


  class LockError(Error):
    pass

  def get_lock_creation_time(self):
    try:
      return os.path.getmtime(self.lock_path)
    except OSError as e:
      if e.errno == errno.ENOENT:
        return None
      raise

  def remove_stale_lock(self, kill_process=True):
    at = self.get_lock_creation_time()
    pid = None
    if (at is not None) and (now() - int(at) > self.valid_for):
      self.msg("Removing stale lock '%s'" % self.lock_path)
      if not gently_kill_process(self.locked_by_pid()):
        raise TimedDirLock.LockError(msgs2str(
                'Unable to kill locking process (', pid, ')'))

      # process is gone. Remove the lock files.
      try:
        shutil.rmtree( self.lock_path )
      except OSError as e:
        if e.errno != errno.ENOENT:
          raise
    return pid

  def __enter__(self):
    if self.acquired:
      self.lock_count += 1
      return
    dirname = os.path.dirname(self.lock_path)
    if not os.path.isdir(dirname):
      os.makedirs(dirname)
    at = now()
    while True:
      try:
        os.mkdir(self.lock_path)
        break
      except OSError as e:
        if e.errno == errno.EEXIST:
          if ((not self.remove_stale_lock())
              and (now() > (at + self.timeout))):
            raise TimedDirLock.LockError(msgs2str(
                'Timeout when trying to acquire lock \'',
                self.lock_path, "' from process ", self.locked_by_pid()))
          time.sleep(self.sleep_time_in_seconds)
          continue
        else:
          raise
    # I got the lock!
    self.acquired = now()
    self.lock_count = 1
    write_file(self.id_file, self.own_id())

  def own_id(self):
    return ':'.join((str(os.getpid()), str(self.id)))

  def locked_by_id(self):
    return read_file(self.id_file)

  def locked_by_pid(self):
    x = self.locked_by_id()
    if ':' in x:
      return int(x.split(':')[0])
    return int(x)

  def verify_lock(self, strict=False, refresh=True):
    if not self.acquired:
      if strict:
        raise TimedDirLock.LockError(msgs2str(
                "Unlock: am not locked to '", self.lock_path, "'"))
      return False
    check = self.locked_by_id()
    if (not check) or (check != self.own_id()):
      self.acquired = None
      self.lock_count = 0
      self.warn("lost lock '", self.lock_path, "'")
      return False
    if refresh:
      os.utime(self.lock_path, None)
    return True

  def __exit__(self, *ignored_args):
    if self.verify_lock(strict=True):
      if self.lock_count > 1:
        self.lock_count -= 1
        return
      self.acquired = None
      self.lock_count = 0
      shutil.rmtree(self.lock_path)

  def __del__(self):
    self.__exit__()


class Tim(Notify):
  seconds_per_minute = 60.0
  stale_threshold = 5 * seconds_per_minute

  def __init__(self, notify_func, config_dir=None):
    Notify.__init__(self, notify_func)
    self.notify = self.notify_func  # just a shortcut

    if not config_dir:
      config_dir = j(os.environ['HOME'], '.tim')
    self.set_config_dir(config_dir)

    self.timelog = Timelog(notify_func, self.timelog_dir)
    self.lock = TimedDirLock(notify_func, self.lock_path)
    #self.lock.remove_stale_lock()

  def set_config_dir(self, config_dir):
    self.config_dir = config_dir
    self.state_file_path = j(config_dir, 'running')
    self.timelog_dir = j(config_dir, 'timelog')
    self.lock_path = j(config_dir, 'lock')

  def new(self, name):
    with self.lock:
      self.timelog.add_name(name)
    self.msg("Added '", name, "'")

  def stop(self, comment=None):
    stopped_state = None
    with self.lock:
      stopped_state = self.get_state()
      t = stopped_state.timing
      if t.started:
        if comment:
          if t.comment:
            t.comment = ' '.join((t.comment, comment))
          else:
            t.comment = comment
        self.timelog.add_timing(t)
        # clear the state on disk
        empty_state = self.get_state(read=False)
        empty_state.save()
      else:
        stopped_state = None # nothing was stopped
    if stopped_state:
      self.notify(Notify.STOPPED, stopped_state)
    return stopped_state

  def handle_stale_state(self, state):
    """see if the daemon was interrupted (e.g. box suspended).
    If so, don't count the time that the daemon was suspended, or
    stop everything, depending on how much time has passed."""
    stale_reason = state.is_stale()
    if stale_reason:
      self.notify(Notify.STALE, state, stale_reason)
      if not gently_kill_process(state.pid):
        self.warn('Unable to kill timer process (', pid, ')')
      # assume the user forgot about me, and exit.
      self.stop()
      # Reload.
      state.read()

  def get_state(self, read=True):
    'return the current state as on disk, no automatic fixing of stale status.'
    return State(self.state_file_path, read)

  def get_status(self):
    'fixes any stale timers, then returns the state.'
    with self.lock:
      state = self.get_state()
      if state.timing.started:
        self.handle_stale_state(state)
      return state

  def start(self, name_to_start, comment=None):
    ''' name_to_start: fully resolved project name ('root.bar.baz') '''
    
    with self.lock:
      state = self.get_state()

    t = state.timing
    if t.started:
      if t.name == name_to_start:
        self.notify(Notify.ALREADY_RUNNING, name_to_start)
        if t.add_comment(comment):
          state.save()
        return True
      self.stop()

    self.notify(Notify.STARTED, name_to_start)

    daemon_out = open('daemon.log', 'a+')
    with daemon.DaemonContext(
             stdout=daemon_out, stderr=daemon_out,
           ):
      try:
        my_pid = os.getpid()

        original_starting_time = str2time( time2str( now() ) )

        state = self.get_state(read=False)
        state.set_values(
          name=name_to_start,
          started=original_starting_time,
          minutes=1,  # <-- debug  minutes=0,
          comment=comment,
          pid=my_pid)
        with self.lock:
          state.save()

        while True:
          # try to run just after the break of the minute
          time.sleep(Tim.seconds_per_minute + 1
                     - (now() % Tim.seconds_per_minute))

          with self.lock:
            # verify that the state still shows the same starting time that
            # I was called to act on.
            state.read()
            t = state.timing
            if t.started:
              self.handle_stale_state(state)
            if not (state.pid == my_pid
                    and t.name == name_to_start):
              # the current state no longer concerns me.
              return

            # all is well, update the state
            t.minutes = ((int(now()) - t.started) 
                         / Tim.seconds_per_minute)
            state.save()
      finally:
        _msg('daemon done')


  def get_log(self, start_date=None, end_date=None):
    with self.lock:
      year = self.timelog.year( time2year(now()) )
      year.read()
      return year

  def adjust_start(self, new_start):
    with self.lock:
      state = self.get_state()
      t = state.timing
      if not t.started:
        _raise('Can only adjust when a timing is running.')
      tnow = now()
      if new_start > tnow:
        _raise('Can only set a starting time that is in the past.')
      t.started = new_start
      t.minutes = int((tnow - new_start) / 60)
      state.save()

  def adjust_add(self, minutes):
    with self.lock:
      state = self.get_state()
      t = state.timing
      t.started -= minutes * 60
      tnow = now()
      t.started = min(t.started, tnow)
      t.minutes = int((tnow - t.started) / 60)
      state.save()

  def adjust_set(self, minutes):
    assert(minutes >= 0)
    with self.lock:
      state = self.get_state()
      t = state.timing
      t.started = now() - (minutes * 60)
      t.minutes = minutes
      state.save()

# invocation via commandline #################################################

help_hint = " -- 'tim help' may help."

class TimCmdline:
  def __init__(self, args):
    self.tim = Tim(self.notify)
    self.args = args

    if any([(arg in args)
            for arg in ('-h', '--help', '-?', '-help', 'help')]):
      self.usage()

    if not args:
      # when called without arguments show status
      function = self.cmd_status
    else:
      cmd = args[0]
      func_name = 'cmd_' + cmd

      function = None
      if hasattr(self, func_name):
        function = getattr(self, func_name)
      if not callable(function):
        # convenience: omit 'adjust' for +-@= time adjustments
        if args[0][0] in '@+-=':
          return self.cmd_adjust(*args)
        if len(args) == 1:
          # convenience: omit 'start' for known project names
          return self.cmd_start(*args)
        _raise("Unknown command: '", cmd, "'", help_hint)

    return function(*(args[1:]))

  def usage(self, error_message=None):
    _msg(__doc__)
    if (error_message):
      _errmsg(error_message)
      exit(1)
    exit(0)

  def cmd_new(self, *args):
    if len(args) > 1:
      _raise("'new' takes only one argument: an unknown name.")
    self.tim.new(args[0])

  def notify(self, key, arg):
    if key == Notify.ALREADY_RUNNING:
      name = str(arg)
      _warn('Already running: ', name)
    elif key == Notify.STOPPED:
      state = arg
      t = state.timing
      _msg('Stopped ', t.name,
           ' (', mins2str(t.minutes), ')')
    elif key == Notify.STARTED:
      name = str(arg)
      _msg('Started ', name)
    elif key == Notify.MSG:
      msg = arg
      _msg(msg)
    elif key == Notify.WARN:
      msg = arg
      _warn(msg)
    elif key == Notify.ERROR:
      msg = arg
      _raise(msg)
    elif key == Notify.STALE:
      state, reason = arg
      t = state.timing
      if reason == State.REASON_STALE:
        reason = 'was not updated for a long time'
      elif reason == State.REASON_DAEMON_EXITED:
        reason = 'the daemon is no longer running'
      _warn('detected undead timer!',
            '\nStopped timer, not counting interrupted time.',
            '\n         name: ', t.name,
            '\n      started: ', time2str(t.started),
            '\n      ran for: ', mins2str(t.minutes),
            '\n  interrupted: ', mins2str((now()-t.started)/60 - t.minutes),
              ' hours ago',
            '\n       reason: ', reason,
            )

  def cmd_start(self, *args):
    if len(args) < 1:
      _raise("'start' takes a name argument.\n", name_syntax_docstr)
    name = self.tim.find_full_name(args[0])
    comment = ' '.join(args[1:])
    if not name:
      _raise("Unknown name: '", args[0], "' -- ",
             "try 'tim new ", args[0], "' first?")
    self.tim.start(name, comment)

  def cmd_stop(self, *args):
    comment = ' '.join(args)
    stopped_state = self.tim.stop(comment)
    # notification
    if not stopped_state:
      _raise('No timer is running.')

  def cmd_status(self, *args):
    if args:
      _raise("'status' takes no arguments")
    status = self.tim.get_status()
    t = status.timing
    if t.started:
      _msg('Running: ', t.name, '=', mins2str(t.minutes), ' (since ',
           time2str(t.started), ')')
    else:
      _msg('Not running.')

  def cmd_totals(self, *args):
    i = 0
    selected = None
    while i < len(args):
      if args[i].startswith('-l'):
        if len(args[i]) > 2:
          l_arg = args[i][2:]
        else:
          i += 1
          if i >= len(args):
            _raise("'totals -l' needs an argument")
          l_arg = args[i]
        selected = l_arg.split(',')
      else:
        _raise("unknown argument for 'totals': '", args[0], "'")
      i += 1

    totals = self.tim.timelog.get_totals()
    if totals.is_empty():
      _msg('Nothing is recorded.')
      return

    if selected:
      names = set()
      for name in selected:
        names.update( totals.find_full_names(name) )
      selected = names

      if not selected:
        _msg('Nothing is recorded for the given selection.')
        return

    if selected:
      _msg('Selection:\n', totals.to_string(selected))
    else:
      _msg('Totals:\n', totals.to_string())

  def cmd_log(self, *args):
    time_period = None
    start = None
    end = None
    if args:
      _raise("'log' arguments not implemented")

    log = self.tim.get_log()
    for entry in log.timings:
      _msg(str(entry))

  def cmd_fix(self, *args):
    clear = False
    start_year = None

    for arg in args:
      if arg == '--clear':
        clear = True
      elif arg.isdigit():
        if start_year:
          _raise('Multiple start years make no sense.')
        start_year = int(arg)
      else:
        _raise("Invalid argument: '", arg , "'", help_hint)

    self.tim.timelog.fix(start_year, clear)

  def cmd_adjust(self, *args):
    if len(args) < 1:
      _raise("'adjust' needs an adjustment argument", help_hint)
    if (len(args) == 2) and (args[0] in ('@', '=', '+', '-')):
      args = (''.join(args),)
    if len(args) != 1:
      _raise("'adjust' takes exactly one argument", help_hint)
    arg = args[0]
    if arg[0] not in '@+-=':
      _raise("invalid 'adjust' argument: '", arg, "'", help_hint)

    cmd = arg[0]
    try:
      minutes_arg = str2mins(arg[1:])
    except FormatError as e:
      _raise("invalid 'adjust' argument: ", e.msg, help_hint)

    if cmd == '@':
      # set starting time
      # get current time less start today (set hours and minutes to zero)
      time_now = now()
      day_start = str2time( time2str(time_now)[:10] + ' 00:00' )
      minutes_today = (time_now - day_start) / 60
      if minutes_arg > minutes_today:
        # the user must have meant yesterday.
        minutes_arg -= 24*60
      new_start = day_start + (minutes_arg * 60)
      self.tim.adjust_start(new_start)
    elif cmd == '+':
      self.tim.adjust_add(minutes_arg)
    elif cmd == '-':
      self.tim.adjust_add(-minutes_arg)
    elif cmd == '=':
      self.tim.adjust_set(minutes_arg)
    else:
      _raise("invalid 'adjust' argument: '", arg, "'", help_hint)
    self.cmd_status()




if __name__ == "__main__":
  # run commandline client.

  try:
    TimCmdline(sys.argv[1:])
  except Error, e:
    _errmsg(str(e))
    print
    raise #exit(-1)

