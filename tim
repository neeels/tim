#!/usr/bin/env python
# coding: utf8
#
# Tim
# ===
# 
# project timer (GUI + cmdline)
# 
# You enter project names and start and stop them.
# Tim will keep track of how much you worked (and when) and how many of these
# worked hours you have already submitted to your money supplier.
# 
# (c) Copyright 2013 by Neels Janosch Hofmeyr <neels@hofmeyr.de> (GPLv3)
# 
# This file is part of Tim project timer.
# 
# Tim project timer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tim project timer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tim project timer.  If not, see <http://www.gnu.org/licenses/>.

'''Tim project timer.

You enter names and start and stop them. Tim tracks how much you worked on
which (and when) and, if you like, how many of these worked hours you have
already submitted to your money supplier.

Make backups of your ~/.tim folder. It contains all of your time logs.

launch a systray icon and GUI:
  tim systray

command line usage:
  tim [status]
  tim new <project-name>
  tim [start] <project-name>
  tim start <project-name> [<comment>]
  tim [adjust] [@<started-time>|+<duration>|-<duration>|=<duration>]
  tim stop [<comment>]
  tim totals [-l <name>[,...]]
  tim log [-l <name>[,...]] [-s <date>] [-d|-w|-m|-y] [-D|-W|-M|-Y] [-n <nr>]
  tim tickoff <hours> [<project-name>] 
  tim tickoff --undo
  tim rename <current-project-name> <new-project-name>
  tim fix [<start-year>] [--clear]
  tim forget <project-name>
  tim remember [<id>] [--as <project-name>] [--add-to <project-name>]


--- tim systray ---
Launch a systray icon. Tim should appear in your window manager's taskbar. Put
'tim systray' in your window manager's autostart. If you click the systray
icon, you can interact with Tim using your mouse ... if you're like that.

--- tim status ---
Calling tim without arguments shows the current timer, if any is running. This
is the same as calling 'tim status'.

--- tim new ---
Announce a new project name. You can use dots '.' to create subgroups of
projects.
  tim new foo
  tim new yoyodyne.abc

--- tim start ---
When you start working on a given project, call 'tim start my_name'. The word
'start' can be omitted. Before you can start a name, you must tell Tim about
it with the 'tim new' command, just once for each name you want to use.

Project names names can be grouped, simply by inserting dots in the name. Any
number of grouping levels is allowed. Any group name can still record timings,
even if it contains other names. Anything that makes sense to you... ;)

As soon as the project name is known ('tim start my_group.my_name'), you only
need to type the part after the last dot ('tim my_name'); Tim will find
'my_group.my_name' from that, as long as there is no other 'my_name' around.

You can supply a comment to go with the timing being started. If you do so,
just write the comment after the name to start. You may not omit the word
'start' when supplying a comment.
  tim start my_name My comment goes everywhere after the name.

The comment will be saved in the log, and it may be used to submit the timing
elsewhere. For example, the OpenGroupware export submits the comment to your
OpenGroupware server.

--- tim adjust ---
When a timer is currently running, adjust the recorded time. This always
shifts the started-time so that the desired duration results when counting up
to the current moment in time. The word 'adjust' may be omitted.

  @<started-time>
    I have actually started working on this project at <started-time>.
    Adjust the timing counter for the current project accordingly.
    <started-time> format is 'HH:MM', e.g. '14:59'. Wraps past midnight
    (yesterday's time is used when today's time would be in the future).
      tim @9      # make as if I called 'start' at 9 o'clock this morning
      tim @15:30  # ... at half past three. 

  +<duration>
    Add <duration> to the currently running timer, make as if I started
    earlier.
    <duration>: [HH][:MM], for example:
      tim +1      # add one hour
      tim +1:30   # add one and a half hours
      tim +1.5    # add one and a half hours (decimal dot)
      tim +:30    # add thirty minutes

  -<duration>
    Subtract <duration>. '-10' is the same as '+-10'. Make as if I started
    later. This won't go below zero.

  =<duration>
    Set the current counter to exactly <duration> hours.
      tim =1      # make as if I called 'start' one hour ago

--- tim stop ---
Stop the currently running timer. Any arguments after the word 'stop' are
stored as a comment for the hours just worked.

--- tim totals ---
Print the current timing totals of hours spent vs. hours ticked-off on a
per-group and per-project basis. Options:
  -l <name>[,<name>[,...]]
    Limit the listing to the given names.

--- tim log ---
Show the timings for this week (-W is the default). Options:
  -l <name>
    Limit the listing to this project (or group).
  Time options:
    default: show each timing in hours and minutes
    -d/-w/-m/-y  combine hours for each day/week/month/year
    -D/-W/-M/-Y  start at the beginning of this day/week/month/year
    -f  start one full time period ago, flowing, floating past boundaries.
        For example, '-f -W' starts seven days ago, instead of last monday;
        '-f -M' starts the same day last month, instead of this month's 1st.
    -n <nr>
       Repeat above time period for <nr> times into the past.
  -s <date>
    Start at <date>, of format 'YYYY-MM-DD_hh:mm', where everything left and
    right of 'hh' may be omitted.
      -s 2013-01-11
        Start at 00:00 on 11th of January, 2013.
      -s 2013-01-11_23:45
        Start at 23:45 on 11th of January, 2013.
      -s 10
        Same as '-s 10:00', start 10 o'clock today
      -s 1_
        Same as '-s 1_0:00', start on the first day of this month
      -s 1-1_
        Same as '-s 1-1_0:00', start on the most recent 1st of January
      -s 3-32_
        Same as '-s 4-1_0:00', start on the most recent 1st of April (wrap!)
      (etc.)

--- tim tickoff ---
Record hours that you have already billed your money supplier for. If you are
timing private / hobby projects, your total hours will simply grow. But if you
have an employer, ticking off is useful to keep track of how many hours you
have actually passed on to your employer's accounting. If you are using
tickoff for any given project, you probably want to reach a total of zero for
that project at regular intervals. If you've worked less than you billed, your
total hours become negative.
- If no project name is supplied, the tickoff is chronologically spread across
  all projects, so that the hours worked longest ago are ticked off first.
    tim tickoff 32
- You can tickoff a group (yoyodyne), in which case the hours contained in any
  sub-projects and sub-sub-projects are ticked-off in their chronological
  order (see examples below). You can also tickoff subprojects specifically.
    tim tickoff 32 yoyodyne
- If a group's total is negative, I've already billed hours I haven't worked
  yet; over time, sub-projects of such a group will receive new hours, but the
  negative total of the parent will only be neutralised at the next tickoff
  command. You may call 'tim tickoff 0 my_name' to chronologically
  neutralise a negative total with hours worked in sub-projects.
- If you want to keep strictly separate project groups, you should take
  care to never call 'tickoff' without a name argument, or hours will be
  neutralised on the root level of all groups. If that should go wrong one
  day, you can undo tickoffs one by one with:
    tim tickoff --undo

--- tim rename ---
Rename a project while keeping its hours and logs. This may also move projects
around between groups.
Note that this changes the name in all logs back to the start of time, so the
'tim log' command will not look the same as before.

--- tim fix ---
Run through the logs, summing up everything, to verify and correct the grand
total shown by 'tim totals', and to verify and correct the initial totals at
the beginning of each log file.
This is particularly useful to edit the recorded timings: simply edit the log
files in ~/.tim/timelog/, then call 'tim fix' to carry the edits through to
following log files and the current grand total.
Without arguments, all available years are checked and corrected. Each year's
final totals are carried over to the next year's initial totals. You can ask
tim to start at a given year if you don't want to run through all of them.
This will *always* run all the way to the present, and will finally adjust the
current grand totals on record if necessary (those shown by 'tim totals').
You can provide the option '--clear' to erase the initial totals of the
starting year. When calling 'tim fix --clear', the first log on record will
have its initial totals reset to zero.
  tim fix
  tim fix 2012  # starts with 2012 and ends with the latest log on record

--- tim forget ---
Remove a given project from accounting. The data will still be sitting in the
database, but it will appear to be completely removed with all its history
when interacting with tim.

--- tim remember ---
Recover a project previously forgotten with 'tim forget'. Run without
arguments to get a listing of IDs for forgotten projects or groups.

--- EXAMPLE ---
  This example shows a sequence of tim commands. Imagine that time passes
  between each pair of start ... stop commands.
  
  tim new foo
  tim foo
  tim stop
  tim foo
  tim stop

  tim new yoyodyne.abc     # announce project abc in group yoyodyne
  tim yoyodyne.abc         # start timing for project abc in the group yoyodyne
  tim +1                   # fake starting-time so that I've worked 1 hour now
  tim stop "fix a bug"     # stop timing, record in the log with a message
  tim abc                  # start yoyodyne.abc; tim finds 'abc' in 'yoyodyne'.
  tim stop
  tim new yoyodyne.xyz.bar # announce project bar in new group yoyodyne.xyz
  tim xyz                  # start yoyodyne.xyz (yes, "groups" can also start)
  tim abc                  # stop yoyodyne.xyz, start yoyodyne.abc, in one go
  tim stop

  tim log                  # show the log of this week (starting monday)
  tim log -w -n 5          # show last five weeks (five times seven days)
  tim log yoyodyne         # show log for yoyodyne.* projects only

  tim totals               # show the sum of all hours for all projects
  tim tickoff 32 yoyodyne  # I have billed yoyodyne for 32 hours.
  tim totals               # Above 32 hours are now subtracted from the totals.
 '''

import re, os, errno, time, shutil, sys, signal
import daemon
import lockfile
from os.path import join as j
from time import time as now


# messaging and error handling ###############################################

def msgs2str(msgs):
  return ''.join([str(m) for m in msgs])

class Error(Exception):
  def __init__(self, *msgs):
    self.msg = msgs2str(msgs)
  def __str__(self):
    return self.__class__.__name__ + ': ' + self.msg

def _raise(*msgs):
  raise Error(*msgs)

def _warn(*msgs):
  print '***', msgs2str(msgs)

def _msg(*msgs):
  print msgs2str(msgs)

def _errmsg(*msgs):
  sys.stderr.write('tim: ')
  for msg in msgs:
    sys.stderr.write(msg)
  sys.stderr.write('\n')
  sys.stderr.flush()
  

# generic conversion functions ###############################################

def mins2str(float_mins):
  sign = 1
  frac = 59.0
  if float_mins < 0:
    float_mins = -float_mins
    sign = -1
    frac = 1.0
  
  minutes = int(float_mins)
  if float_mins - float(minutes) > (frac/60):
    minutes += 1

  h, m = divmod(minutes, 60)

  if m == 0:
    return str(sign * h)
  elif sign < 0:
    # just 'h *= sign' won't work if h == 0.
    return "-%d:%02d" % (h,m)
  else:
    return "%d:%02d" % (h,m)

class FormatError(Error):
  pass

def str2mins(str_hours):
  try: 
    if str_hours.find(':') < 0:
      return int(round(float(str_hours) * 60.0))

    h, m = str_hours.split(':')
    sign = 1
    if h.startswith('+'):
      h = h[1:]
    if h.startswith('-'):
      h = h[1:]
      sign = -1

    if not h or len(h) < 1:
      fh = 0
    else:
      fh = float(h)

    if not m or len(m) < 1:
      fm = 0
    else:
      fm = float(m)

    return int(sign * round(fh * 60.0 + fm))
  except Exception, e:
    raise FormatError("Not a time string: '", str_hours, "'")

TIMESTR_FORMAT = "%Y-%m-%d %H:%M"
FILENAME_TIMESTAMP_FORMAT = "%Y_%m_%d_%H_%M_%S"

def time2str(float_time):
  if not float_time:
    return None
  return time.strftime(TIMESTR_FORMAT, time.localtime(float(float_time)))

def str2time(str):
  if not str or len(str) < 1:
    return None
  return time.mktime( time.strptime(str, TIMESTR_FORMAT) )

def time2year(float_time):
  return int(time.strftime('%Y', time.localtime(float_time)))

def filename_timestamp(float_time=None):
  if float_time is None:
    float_time = float(time.time())
  return time.strftime(FILENAME_TIMESTAMP_FORMAT,
                       time.localtime(float(float_time)))

# os file & process functions ################################################

def write_file(path, contents, mkdirs=True):
  if mkdirs:
    dirname = os.path.dirname(path)
    if not os.path.exists(dirname):
      os.makedirs(dirname)
  f = open(path, "w")
  f.write(contents)
  f.close()

def append_to_file(path, *contents):
  f = open(path, "a")
  for c in contents:
    f.write(c)
  f.close()

def read_file(path):
  try:
    f = open(path, "r")
    contents = f.read()
    f.close()
    return contents
  except IOError:
    return None

def read_file_lines(path):
  try:
    f = open(path, "r")
    contents = f.readlines()
    f.close()
    return contents
  except IOError:
    return None

def process_is_running(pid):
  try:
    os.kill(int(pid), 0)
    return True
  except OSError as e:
    if e.errno == errno.ESRCH: # no such process
      return False
    raise

def gently_kill_process(pid):
  if not (pid and process_is_running(pid)):
    return True
  _msg('kill -SIGINT ', pid)
  os.kill(pid, signal.SIGINT)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  _msg('kill -SIGTERM ', pid)
  os.kill(pid, signal.SIGTERM)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  _msg('kill -SIGKILL ', pid)
  os.kill(pid, signal.SIGKILL)
  time.sleep(0.1)
  if not process_is_running(pid):
    return True
  time.sleep(2)
  if not process_is_running(pid):
    return True
  return False
 

# strings and regexes ########################################################

INITIAL_TOTAL_KEYWORD = 'init:'
NAME_RE = '([a-zA-Z_][a-zA-Z0-9_]*\.)*[a-zA-Z_][a-zA-Z0-9_]*'
TIME_RE = '[+-]{0,1}[0-9:]+'
DATE_RE = r'(\d{1,4})-(\d{1,2})-(\d{1,2})[_ ](\d{1,2})[-:](\d{1,2})'
NAME_STR_RE = '\A' + NAME_RE + '\Z'
TOTAL_RE = '(' + NAME_RE + ')=(' + TIME_RE + ')'
TOTALS_LINE_RE = '^' + TOTAL_RE + '$'
LOG_INITIAL_TOTAL_RE = '^' + INITIAL_TOTAL_KEYWORD + ' *(.*) *$'
TIMING_RE = '^' + DATE_RE + '[: ]+([^ ]+) (' + TIME_RE + ')($| *# {0,1}(.*)$)'
STATE_RE = '^([0-9]+) (.*)$' # a PID, and a log entry (parsed in second step)

name_syntax_docstr = (
'''A name may only contain letters a-z, A-Z, decimal numbers and the underscore _;
A name may not start with a number. Names can be arranged in groups, by using
a dot to separate group levels: 'tim new my_group.my_inner_group.my_name'.''')

class Regex:
  '''Caches compiled regular expressions. A call to
  Regex.match('([a-z]*) ([0-9]*)', 'foo 123') returns a re.match object and
  compiles that regex only once, no matter how often match() is called.'''
  cache = {}
  @staticmethod
  def compiled(regex):
    compiled = Regex.cache.get(regex)
    if not compiled:
      compiled = re.compile(regex)
      Regex.cache[regex] = compiled
    return compiled
  @staticmethod
  def match(regex, string):
    return Regex.compiled(regex).match(string)
    

# classes implementing Tim ###################################################

class Notify(object):
  def __init__(self, notify_func):
    ''' notify_func(key, arg): function that notifies the user; the
    calling code can/should show these messages to the user in some way.

    key: One of the Notify.CONSTANTs
    
    arg: depends on the key...

      Notify.STARTED,
      Notify.ALREADY_RUNNING:
        arg: the name of the project that was successfully started / stopped
              / was not started since the same name is already running.

      Notify.STOPPED,
        arg: a State instance reflecting the state that has just been stopped
             and recorded in the time log.

      Notify.STALE:
        arg: (state, reason)
             state: a State instance like with Notify.STOPPED.
             reason: a short string meaning
               reason == State.REASON_STALE:
                 The state was last updated too long ago, i.e.  state.started
                 and state.minutes don't add up to the current time.
               reason == State.REASON_DAEMON_EXITED:
                 There is no process with PID == state.pid, so the daemon
                 updating the state has exited.
             A stale state is a running state that has not been updated for a
             long time, maybe because the machine was suspended or crashed.
             The timing was saved to the time log, only counting the time that
             the state was being updated (state.timing.minutes).

      Notify.MSG,
      Notify.WARN,
      Notify.ERROR:
        arg: a message to display.
    '''
    self.notify_func = notify_func

  def msg(self, *msgs):
    if self.notify_func:
      self.notify_func(Notify.MSG, msgs2str(msgs))

  def warn(self, *msgs):
    if self.notify_func:
      self.notify_func(Notify.WARN, msgs2str(msgs))

  def err(self, *msgs):
    if self.notify_func:
      self.notify_func(Notify.ERROR, msgs2str(msgs))

  ALREADY_RUNNING = 0
  STARTED = 1
  STOPPED = 2
  STALE = 3
  MSG = 4
  WARN = 5
  ERROR = 6



class Timing:
  def __init__(self, **kwargs):
    self.set_values(**kwargs)
  
  def set_values(self, started=None, name=None, minutes=None, comment=None):
    if name:
      Timelog.validate_name(name)
    self.started = started
    self.name = name
    self.minutes = minutes
    self.comment = comment
    if not self.comment:
      self.comment = None
    return self

  def clear(self):
    self.set_values()

  def started_str(self):
    return time2str(self.started)

  def serialize(self):
    return repr(self) + '\n'

  def __str__(self):
    return repr(self)

  def __repr__(self):
    if self.started:
      started_str = self.started_str()
    else:
      started_str = 'not_started'
    elts = [started_str,
            self.name or 'unnamed',
            mins2str(self.minutes or 0)]
    if self.comment:
      elts.append('#')
      elts.append(self.comment)
    return ' '.join(elts)

  def deserialize(self, line):
    match = Regex.match(TIMING_RE, line)
    if not match:
      return None
    else:
      self.set_values(
                    started=str2time('%s-%s-%s %s:%s' % match.groups()[0:5]),
                    name=match.group(6),
                    minutes=str2mins(match.group(7)),
                    comment=match.group(9),
                   )
      return self

  def add_comment(self, comment):
    'Append to current comment. Return True iff self.comment changed.'
    if comment:
      was = self.comment
      self.comment = (self.comment or '') + comment
      if was != self.comment:
        return True
    return False


class State:
  STOPPED = 'stopped'

  def __init__(self, state_file_path, read=True):
    self.timing = Timing()
    self.pid = None
    self.state_file_path = state_file_path
    if self.state_file_path and read:
      self.read()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    if self.timing.started:
      return str(self.pid) + ' ' + self.timing.serialize()
    else:
      return State.STOPPED

  def set_values(self, pid=None, **kwargs):
    self.pid = pid
    return self.timing.set_values(**kwargs)

  def serialize(self):
    return repr(self) + '\n'

  def deserialize(self, string):
    match = Regex.match(STATE_RE, string)
    if not match:
      return False
    # State only adds the pid field to Timing, so
    # STATE_RE only adds a pid nr to TIMING_RE
    self.pid = int(match.group(1))
    self.timing.deserialize(match.group(2))
    return True

  def save(self):
    "write this state to file"
    write_file(self.state_file_path, self.serialize())
    return self

  def clear(self):
    self.pid = None
    self.timing.clear()

  def read(self):
    self.clear()

    if not os.path.isfile(self.state_file_path):
      return False

    statestr = read_file(self.state_file_path)
    if statestr is None:
      return True # stopped. no data.
    statestr = statestr.strip()
    if statestr == State.STOPPED:
      return True # stopped. no data.

    return self.deserialize(statestr)

  REASON_STALE = 'stale'
  REASON_DAEMON_EXITED = 'daemon exited'

  def is_stale(self):
    assert(self.timing.started)
    expected_now = (self.timing.started 
                    + (self.timing.minutes * Tim.seconds_per_minute))
    timestep = now() - expected_now
    if timestep > Tim.stale_threshold:
      return State.REASON_STALE
    if not process_is_running(self.pid):
      return State.REASON_DAEMON_EXITED
    return None


class Totals(Notify):
  def __init__(self, notify_func, totals_path=None, read=True):
    self.entries = {}
    self.notify_func = notify_func
    self.totals_path = totals_path
    if totals_path and read:
      self.read()

  def set_to(self, other_totals_instance):
    self.entries = other_totals_instance.entries.copy()
    return self

  def copy(self):
    Totals(self.notify_func).set_to(self)

#  def add_all(self, other_totals_instance):
#    for name, minutes in other_totals_instance.iteritems():
#      self._add_timing(name, minutes)

  class TotalsErr(Error):
    pass

  def add_name(self, name):
    if name in self.entries:
      raise TotalsErr("Already exists: '", name, "'")
    self.entries[name] = 0

  def _add_timing(self, name, minutes):
    self.entries[name] = (self.get(name) or 0) + minutes

  def add_timing(self, timing):
    self._add_timing(timing.name, timing.minutes)

  def get(self, *args):
    return self.entries.get(*args)

  def iteritems(self):
    return self.entries.iteritems()

  def __iter__(self, *args):
    return self.entries.__iter__(*args)

  def __eq__(self, other):
    return self.entries.__eq__(other.entries)
  def __ne__(self, other):
    return self.entries.__ne__(other.entries)

  def is_empty(self, selected=None):
    if not selected:
      return not self.entries
    return not [item for item in self.entries if item in selected]

  def deserialize(self, line):
    match = Regex.match(TOTALS_LINE_RE, line)
    if not match:
      raise TotalsErr('Line does not match "' + TOTALS_LINE_RE + '"')
    name = match.group(1)
    Timelog.validate_name(name)
    minutes = str2mins(match.group(3))
    if name in self.entries:
      raise TotalsErr('Duplicate name: ' + name)
    self.entries[name] = minutes

  def read(self):
    lines = read_file_lines(self.totals_path)
    self.entries = {}
    if lines:
      line_nr = 0
      for line in lines:
        line_nr += 1
        if not line.strip():
          continue
        try:
          self.deserialize(line)
        except Totals.TotalsErr as e:
          self.warn('DROPPING line ', line_nr, ' from ', self.totals_path,
                    ': ', e.msg, '\n', line_nr, ':', line)

  def get_serialized_items(self):
    return [ ( '%s=%s\n' % (name, mins2str(minutes)) )
            for name, minutes in sorted(self.iteritems())]

  def __repr__(self):
    return ''.join(self.get_serialized_items())

  def save(self):
    assert(self.totals_path)
    write_file(self.totals_path, repr(self))

  def clear(self):
    self.entries = {}

  def to_string(self, selected=None):
    items = []
    seen = set()

    for name, minutes in self.iteritems():
      if (not selected) or (name in selected):
        items.append((name, minutes))
        seen.add(name)
    
    if selected:
      for name in selected:
        if not name in seen:
          items.append((name, 0))
          seen.add(name)

    def tostr(name, minutes):
      mins_str = mins2str(minutes)
      if not ':' in mins_str:
        mins_str = '%6s   ' % mins_str
      else:
        mins_str = '%9s' % mins_str
      return msgs2str((mins_str, ' ', name))

    out = []
    grand_total = 0
    for name, minutes in sorted(items):
      grand_total += minutes
      out.append(tostr(name, minutes))

    out.append('    =====')
    out.append(tostr('', grand_total))
    return '\n'.join(out)

  def __str__(self):
    return self.to_string(None)

  def find_full_names(self, name):
    with_children = False
    only_children = False
    if name.endswith('*'):
      name = name[:-1]
      with_children = True
      if name.endswith('.'):
        name = name[:-1]
        only_children = True
        
    Timelog.validate_name(name)

    matches = set()
    if (not only_children) and (name in self.entries):
      matches.add(name)

    for known_name in self.entries:
      tokens = known_name.split('.')
      while tokens:
        if name == tokens[-1]:
          matches.add('.'.join(tokens))
        del tokens[-1]

    if with_children:
      children = set()
      for name in matches:
        children.update(self.find_all_children(name))

      if only_children:
        matches = children
      else:
        matches.update(children)

    return matches

  def find_full_name(self, name):
    matches = self.find_full_names(name)
    if name in matches:
      return name
    if len(matches) > 1:
      _raise("Multiple matches found for '", name, "':\n",
             '\n'.join([('- ' + m) for m in sorted(matches)]))
    elif len(matches) == 1:
      return matches.pop()
    else:
      return None

  def find_all_children(self, name):
    Timelog.validate_name(name)
    children = []
    for known_name in self.entries:
      if known_name.startswith(name) and known_name != name:
        children.append(known_name)
    return children

class Timelog(Notify):

  def __init__(self, notify_func, timelog_dir):
    Notify.__init__(self, notify_func)
    self.timelog_dir = timelog_dir
    self.totals_path = j(self.timelog_dir, 'totals')
    self.clear()

  def clear(self):
    self.timelog_files = {}

  class InvalidNameError(Error):
    pass

  @staticmethod
  def validate_name(name):
    if not Regex.match(NAME_STR_RE, name):
      raise Timelog.InvalidNameError(
               "Invalid name: '", name, "'\n",
               name_syntax_docstr)

  def get_totals(self):
    return Totals(self.notify_func, self.totals_path)

  def add_name(self, name):
    Timelog.validate_name(name)
    t = self.get_totals()
    t.add_name(name)
    t.save()

  def add_timing(self, timing):
    timings_file = self.year()
    timings_file.add_timing(timing)
    t = self.get_totals()
    t.add_timing(timing)
    t.save()


  class TimingsFile(Notify):
    def __init__(self, notify_func, path, read=True):
      Notify.__init__(self, notify_func)
      self.path = path
      self.entries = None
      self.totals = None
      self.initial_totals = None
      self.exists = None
      if read:
        self.read()

    def read(self):
      self.exists = False
      try:
        lf = open(self.path, "r")
        self.exists = True
      except IOError as e:
        if e.errno == errno.ENOENT:
          self.entries = []
          self.initial_totals = Totals(self.notify_func)
          self.totals = Totals(self.notify_func)
          self.exists = False
          return
        raise

      try:
        self.entries = []
        self.initial_totals = Totals(self.notify_func)

        line_nr = 0

        # read initial totals
        while True:
          at = lf.tell()
          line = lf.readline()
          line_nr += 1
          match = Regex.match(LOG_INITIAL_TOTAL_RE, line)
          if match:
            total_string = match.group(1)
            self.initial_totals.deserialize(total_string)
          else:
            # done with initial totals.
            # unread last line, continue below.
            lf.seek(at)
            line_nr -= 1
            break

        self.totals = self.initial_totals.copy()

        while True:
          line = lf.readline()
          line_nr += 1
          if not line:
            break

          t = Timing().deserialize(line)
          if not t:
            _raise('cannot parse line ', line_nr, ' in timelog file ', 
                   self.path)
          self.entries.append(t)

        self.update_totals()

      finally:
        lf.close()

    def update_totals(self):
      self.totals = Totals(self.notify_func)
      self.totals.set_to(self.initial_totals)
      for t in self.entries:
        self.totals.add_timing(t)

    def add_timing(self, timing):
      assert(isinstance(timing, Timing))
      if timing.minutes == 0:
        return
      append_to_file(self.path, timing.serialize())
      self.entries.append(timing)
      self.update_totals()

    def save(self):
      lines = [ ' '.join((INITIAL_TOTAL_KEYWORD, line))
                for line in self.initial_totals.get_serialized_items() ]
      lines.extend([ t.serialize() for t in self.entries ])
      write_file(self.path, ''.join(lines))

  def path_for_year(self, year):
    return j(self.timelog_dir, str(int(year)))

  @staticmethod
  def current_year():
    return time2year(now())

  def year(self, year=None):
    if year is None:
      year = Timelog.current_year()
    year = int(year)
    timings_file = self.timelog_files.get(year)
    if not timings_file:
      timings_file = Timelog.TimingsFile(self.notify_func,
                                         self.path_for_year(year))
      self.timelog_files[year] = timings_file
      timings_file.read()
    return timings_file
    
  def years_available(self):
    files = os.listdir(self.timelog_dir)
    return [int(name) for name in files
            if name.isdigit() and os.path.isfile(j(self.timelog_dir, name))]

  def fix(self, start_year=None, clear=False):
    unfixed = 0
    fixes_made = 0

    if start_year:
      start_year = int(start_year)

    def diff_totals(t_is, t_shouldbe):
      for name, minutes in sorted(t_is.iteritems()):
        shouldbe_minutes = t_shouldbe.get(name)
        if shouldbe_minutes != minutes:
          if shouldbe_minutes is None:
            shouldbe_str = ', but there is no prior record of that name.'
          else:
            shouldbe_str = ', should be ' + mins2str(shouldbe_minutes)
          self.msg(' - ', name, ' is ', mins2str(minutes), shouldbe_str)
      for name,minutes in sorted(t_shouldbe.iteritems()):
        if not name in t_is:
          self.msg(' - ', name, ' is missing, should be ', mins2str(minutes))

    prev_totals = None

    years_available = self.years_available()
    years_available = range(min(years_available), max(years_available)+1)

    if not start_year:
      start_year = years_available[0]
    elif start_year not in years_available:
      _raise('No record for ', start_year)

    for yearnr in years_available:
      if yearnr < start_year:
        continue
      year = self.year(yearnr)
      if not year.exists:
        self.warn('No log for ', yearnr)

      changed_initial_totals = False

      if (not prev_totals) and (not year.initial_totals.is_empty()):
        if clear:
          save_path = j(os.path.dirname(year.path),
                        'initial_totals_of_' + os.path.basename(year.path)
                        + '_removed_at_' + filename_timestamp())
          self.msg('** clearing initial totals of ', yearnr, '\n',
                   '** saving to: ', save_path)
          write_file(save_path, repr(year.initial_totals))
          year.initial_totals.clear()
          changed_initial_totals = True
          fixes_made += 1
        elif yearnr == years_available[0]:
          unfixed += 1
          self.warn('NOT FIXING: ', yearnr, ' is the first year on record, ',
                    'but it has initial totals:\n',
                    '\n'.join([ ('*** ' + line) 
                                for line in
                                str(year.initial_totals).split('\n')]))
        else:
          self.msg('Starting off with initial totals of ', yearnr)
        
      elif prev_totals and (prev_totals != year.initial_totals):
        self.msg('** fixing: the initial totals in ', yearnr, ' are wrong.')
        diff_totals(year.initial_totals, prev_totals)

        year.initial_totals.set_to(prev_totals)
        changed_initial_totals = True
        fixes_made += 1

      if changed_initial_totals:
        year.update_totals()
        year.save()

      prev_totals = year.totals

    # finally, update the current grand totals to the last totals seen
    if prev_totals:
      totals = self.get_totals()
      if totals != prev_totals:
        self.msg('** fixing: the grand totals are wrong.')
        diff_totals(totals, prev_totals)
        totals.set_to(prev_totals)
        totals.save()
        fixes_made += 1

    if (fixes_made < 1) and (unfixed < 1):
      self.msg('All correct.')
    else:
      if fixes_made:
        self.msg('** errors fixed: ', fixes_made)
      if unfixed:
        self.warn('unfixed errors: ', unfixed)

class TimedDirLock(Notify):
  id_count = 0

  def __init__(self, notify_func, lock_path,
               sleep_time_in_seconds=1.0, timeout=30, valid_for=10):
    Notify.__init__(self, notify_func)
    self.lock = self.__enter__
    self.unlock = self.__exit__
    self.lock_path = lock_path
    self.sleep_time_in_seconds = sleep_time_in_seconds
    self.timeout = timeout
    self.valid_for = valid_for
    self.acquired = None
    self.id_file = j(self.lock_path, 'pid')
    self.id = TimedDirLock.id_count
    TimedDirLock.id_count += 1
    self.lock_count = 0


  class LockError(Error):
    pass

  def get_lock_creation_time(self):
    try:
      return os.path.getmtime(self.lock_path)
    except OSError as e:
      if e.errno == errno.ENOENT:
        return None
      raise

  def remove_stale_lock(self, kill_process=True):
    at = self.get_lock_creation_time()
    pid = None
    if (at is not None) and (now() - int(at) > self.valid_for):
      self.msg("Removing stale lock '%s'" % self.lock_path)
      if not gently_kill_process(self.locked_by_pid()):
        raise TimedDirLock.LockError(msgs2str(
                'Unable to kill locking process (', pid, ')'))

      # process is gone. Remove the lock files.
      try:
        shutil.rmtree( self.lock_path )
      except OSError as e:
        if e.errno != errno.ENOENT:
          raise
    return pid

  def __enter__(self):
    if self.acquired:
      self.lock_count += 1
      return
    dirname = os.path.dirname(self.lock_path)
    if not os.path.isdir(dirname):
      os.makedirs(dirname)
    at = now()
    while True:
      try:
        os.mkdir(self.lock_path)
        break
      except OSError as e:
        if e.errno == errno.EEXIST:
          if ((not self.remove_stale_lock())
              and (now() > (at + self.timeout))):
            raise TimedDirLock.LockError(msgs2str(
                'Timeout when trying to acquire lock \'',
                self.lock_path, "' from process ", self.locked_by_pid()))
          time.sleep(self.sleep_time_in_seconds)
          continue
        else:
          raise
    # I got the lock!
    self.acquired = now()
    self.lock_count = 1
    write_file(self.id_file, self.own_id())

  def own_id(self):
    return ':'.join((str(os.getpid()), str(self.id)))

  def locked_by_id(self):
    return read_file(self.id_file)

  def locked_by_pid(self):
    x = self.locked_by_id()
    if ':' in x:
      return int(x.split(':')[0])
    return int(x)

  def verify_lock(self, strict=False, refresh=True):
    if not self.acquired:
      if strict:
        raise TimedDirLock.LockError(msgs2str(
                "Unlock: am not locked to '", self.lock_path, "'"))
      return False
    check = self.locked_by_id()
    if (not check) or (check != self.own_id()):
      self.acquired = None
      self.lock_count = 0
      self.warn("lost lock '", self.lock_path, "'")
      return False
    if refresh:
      os.utime(self.lock_path, None)
    return True

  def __exit__(self, *ignored_args):
    if self.verify_lock(strict=True):
      if self.lock_count > 1:
        self.lock_count -= 1
        return
      self.acquired = None
      self.lock_count = 0
      shutil.rmtree(self.lock_path)

  def __del__(self):
    self.__exit__()


class Tim(Notify):
  seconds_per_minute = 60.0
  stale_threshold = 5 * seconds_per_minute

  def __init__(self, notify_func, config_dir=None):
    Notify.__init__(self, notify_func)
    self.notify = self.notify_func  # just a shortcut

    if not config_dir:
      config_dir = j(os.environ['HOME'], '.tim')
    self.set_config_dir(config_dir)

    self.timelog = Timelog(notify_func, self.timelog_dir)
    self.lock = TimedDirLock(notify_func, self.lock_path)
    #self.lock.remove_stale_lock()

  def set_config_dir(self, config_dir):
    self.config_dir = config_dir
    self.state_file_path = j(config_dir, 'running')
    self.timelog_dir = j(config_dir, 'timelog')
    self.lock_path = j(config_dir, 'lock')

  def new(self, name):
    with self.lock:
      self.timelog.add_name(name)
    self.msg("Added '", name, "'")

  def stop(self, comment=None):
    stopped_state = None
    with self.lock:
      stopped_state = self.get_state()
      t = stopped_state.timing
      if t.started:
        if comment:
          if t.comment:
            t.comment = ' '.join((t.comment, comment))
          else:
            t.comment = comment
        self.timelog.add_timing(t)
        # clear the state on disk
        empty_state = self.get_state(read=False)
        empty_state.save()
      else:
        stopped_state = None # nothing was stopped
    if stopped_state:
      self.notify(Notify.STOPPED, stopped_state)
    return stopped_state

  def handle_stale_state(self, state):
    """see if the daemon was interrupted (e.g. box suspended).
    If so, don't count the time that the daemon was suspended, or
    stop everything, depending on how much time has passed."""
    stale_reason = state.is_stale()
    if stale_reason:
      self.notify(Notify.STALE, state, stale_reason)
      if not gently_kill_process(state.pid):
        self.warn('Unable to kill timer process (', pid, ')')
      # assume the user forgot about me, and exit.
      self.stop()
      # Reload.
      state.read()

  def get_state(self, read=True):
    'return the current state as on disk, no automatic fixing of stale status.'
    return State(self.state_file_path, read)

  def get_status(self):
    'fixes any stale timers, then returns the state.'
    with self.lock:
      state = self.get_state()
      if state.timing.started:
        self.handle_stale_state(state)
      return state

  def start(self, name_to_start, comment=None):
    ''' name_to_start: fully resolved project name ('root.bar.baz') '''
    
    with self.lock:
      state = self.get_state()

    t = state.timing
    if t.started:
      if t.name == name_to_start:
        self.notify(Notify.ALREADY_RUNNING, name_to_start)
        if t.add_comment(comment):
          state.save()
        return True
      self.stop()

    self.notify(Notify.STARTED, name_to_start)

    daemon_out = open('daemon.log', 'a+')
    with daemon.DaemonContext(
             stdout=daemon_out, stderr=daemon_out,
           ):
      try:
        my_pid = os.getpid()

        original_starting_time = str2time( time2str( now() ) )

        state = self.get_state(read=False)
        state.set_values(
          name=name_to_start,
          started=original_starting_time,
          minutes=1,  # <-- debug  minutes=0,
          comment=comment,
          pid=my_pid)
        with self.lock:
          state.save()

        while True:
          # try to run just after the break of the minute
          time.sleep(Tim.seconds_per_minute + 1
                     - (now() % Tim.seconds_per_minute))

          with self.lock:
            # verify that the state still shows the same starting time that
            # I was called to act on.
            state.read()
            t = state.timing
            if t.started:
              self.handle_stale_state(state)
            if not (state.pid == my_pid
                    and t.name == name_to_start):
              # the current state no longer concerns me.
              return

            # all is well, update the state
            t.minutes = ((int(now()) - t.started) 
                         / Tim.seconds_per_minute)
            state.save()
      finally:
        _msg('daemon done')

  def get_log(self, start_date=None, end_date=None):
    with self.lock:
      year = self.timelog.year( time2year(now()) )
      year.read()
      return year

  def adjust_start(self, new_start):
    with self.lock:
      state = self.get_state()
      t = state.timing
      if not t.started:
        _raise('Can only adjust when a timing is running.')
      tnow = now()
      if new_start > tnow:
        _raise('Can only set a starting time that is in the past.')
      t.started = new_start
      t.minutes = int((tnow - new_start) / 60)
      state.save()

  def adjust_add(self, minutes):
    with self.lock:
      state = self.get_state()
      t = state.timing
      t.started -= minutes * 60
      tnow = now()
      t.started = min(t.started, tnow)
      t.minutes = int((tnow - t.started) / 60)
      state.save()

  def adjust_set(self, minutes):
    assert(minutes >= 0)
    with self.lock:
      state = self.get_state()
      t = state.timing
      t.started = now() - (minutes * 60)
      t.minutes = minutes
      state.save()

# invocation via commandline #################################################

help_hint = " -- 'tim help' may help."

class TimCmdline:
  def __init__(self, args):
    self.tim = Tim(self.notify)
    self.args = args

    if any([(arg in args)
            for arg in ('-h', '--help', '-?', '-help', 'help')]):
      self.usage()

    if not args:
      # when called without arguments show status
      function = self.cmd_status
    else:
      cmd = args[0]
      func_name = 'cmd_' + cmd

      function = None
      if hasattr(self, func_name):
        function = getattr(self, func_name)
      if not callable(function):
        # convenience: omit 'adjust' for +-@= time adjustments
        if args[0][0] in '@+-=':
          return self.cmd_adjust(*args)
        if len(args) == 1:
          # convenience: omit 'start' for known project names
          return self.cmd_start(*args)
        _raise("Unknown command: '", cmd, "'", help_hint)

    return function(*(args[1:]))

  def usage(self, error_message=None):
    _msg(__doc__)
    if (error_message):
      _errmsg(error_message)
      exit(1)
    exit(0)

  def cmd_new(self, *args):
    if len(args) > 1:
      _raise("'new' takes only one argument: an unknown name.")
    self.tim.new(args[0])

  def notify(self, key, arg):
    if key == Notify.ALREADY_RUNNING:
      name = str(arg)
      _warn('Already running: ', name)
    elif key == Notify.STOPPED:
      state = arg
      t = state.timing
      _msg('Stopped ', t.name,
           ' (', mins2str(t.minutes), ')')
    elif key == Notify.STARTED:
      name = str(arg)
      _msg('Started ', name)
    elif key == Notify.MSG:
      msg = arg
      _msg(msg)
    elif key == Notify.WARN:
      msg = arg
      _warn(msg)
    elif key == Notify.ERROR:
      msg = arg
      _raise(msg)
    elif key == Notify.STALE:
      state, reason = arg
      t = state.timing
      if reason == State.REASON_STALE:
        reason = 'was not updated for a long time'
      elif reason == State.REASON_DAEMON_EXITED:
        reason = 'the daemon is no longer running'
      _warn('detected undead timer!',
            '\nStopped timer, not counting interrupted time.',
            '\n         name: ', t.name,
            '\n      started: ', time2str(t.started),
            '\n      ran for: ', mins2str(t.minutes),
            '\n  interrupted: ', mins2str((now()-t.started)/60 - t.minutes),
              ' hours ago',
            '\n       reason: ', reason,
            )

  def cmd_start(self, *args):
    if len(args) < 1:
      _raise("'start' takes a name argument.\n", name_syntax_docstr)
    name = self.tim.find_full_name(args[0])
    comment = ' '.join(args[1:])
    if not name:
      _raise("Unknown name: '", args[0], "' -- ",
             "try 'tim new ", args[0], "' first?")
    self.tim.start(name, comment)

  def cmd_stop(self, *args):
    comment = ' '.join(args)
    stopped_state = self.tim.stop(comment)
    # notification
    if not stopped_state:
      _raise('No timer is running.')

  def cmd_status(self, *args):
    if args:
      _raise("'status' takes no arguments")
    status = self.tim.get_status()
    t = status.timing
    if t.started:
      _msg('Running: ', t.name, '=', mins2str(t.minutes), ' (since ',
           time2str(t.started), ')')
    else:
      _msg('Not running.')

  def cmd_totals(self, *args):
    i = 0
    selected = None
    while i < len(args):
      if args[i].startswith('-l'):
        if len(args[i]) > 2:
          l_arg = args[i][2:]
        else:
          i += 1
          if i >= len(args):
            _raise("'totals -l' needs an argument")
          l_arg = args[i]
        selected = l_arg.split(',')
      else:
        _raise("unknown argument for 'totals': '", args[0], "'")
      i += 1

    totals = self.tim.timelog.get_totals()
    if totals.is_empty():
      _msg('Nothing is recorded.')
      return

    if selected:
      names = set()
      for name in selected:
        names.update( totals.find_full_names(name) )
      selected = names

      if not selected:
        _msg('Nothing is recorded for the given selection.')
        return

    if selected:
      _msg('Selection:\n', totals.to_string(selected))
    else:
      _msg('Totals:\n', totals.to_string())

  def cmd_log(self, *args):
    if args:
      _raise("'log' arguments not implemented")

    log = self.tim.get_log()
    for entry in log.entries:
      _msg(str(entry))

  def cmd_fix(self, *args):
    clear = False
    start_year = None

    for arg in args:
      if arg == '--clear':
        clear = True
      elif arg.isdigit():
        if start_year:
          _raise('Multiple start years make no sense.')
        start_year = int(arg)
      else:
        _raise("Invalid argument: '", arg , "'", help_hint)

    self.tim.timelog.fix(start_year, clear)

  def cmd_adjust(self, *args):
    if len(args) < 1:
      _raise("'adjust' needs an adjustment argument", help_hint)
    if (len(args) == 2) and (args[0] in ('@', '=', '+', '-')):
      args = (''.join(args),)
    if len(args) != 1:
      _raise("'adjust' takes exactly one argument", help_hint)
    arg = args[0]
    if arg[0] not in '@+-=':
      _raise("invalid 'adjust' argument: '", arg, "'", help_hint)

    cmd = arg[0]
    try:
      minutes_arg = str2mins(arg[1:])
    except FormatError as e:
      _raise("invalid 'adjust' argument: ", e.msg, help_hint)

    if cmd == '@':
      # set starting time
      # get current time less start today (set hours and minutes to zero)
      time_now = now()
      day_start = str2time( time2str(time_now)[:10] + ' 00:00' )
      minutes_today = (time_now - day_start) / 60
      if minutes_arg > minutes_today:
        # the user must have meant yesterday.
        minutes_arg -= 24*60
      new_start = day_start + (minutes_arg * 60)
      self.tim.adjust_start(new_start)
    elif cmd == '+':
      self.tim.adjust_add(minutes_arg)
    elif cmd == '-':
      self.tim.adjust_add(-minutes_arg)
    elif cmd == '=':
      self.tim.adjust_set(minutes_arg)
    else:
      _raise("invalid 'adjust' argument: '", arg, "'", help_hint)
    self.cmd_status()




if __name__ == "__main__":
  # run commandline client.

  try:
    TimCmdline(sys.argv[1:])
  except Error, e:
    _errmsg(str(e))
    print
    raise #exit(-1)

